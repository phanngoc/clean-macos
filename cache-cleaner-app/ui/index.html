<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Cleaner</title>
  <!-- Google AdSense SDK -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-PLACEHOLDER"
     crossorigin="anonymous"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 20px; font-weight: 300; }
    h2 { font-size: 16px; margin: 20px 0 10px; color: #888; }
    .cache-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .cache-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cache-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .cache-info { flex: 1; }
    .cache-name { font-weight: 500; font-size: 15px; }
    .cache-path { font-size: 11px; color: #888; margin-top: 3px; word-break: break-all; }
    .cache-size { font-size: 14px; color: #4ade80; font-weight: 500; }
    .cache-size.large { color: #f87171; }
    .actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-scan { background: #3b82f6; color: #fff; }
    .btn-preview { background: #8b5cf6; color: #fff; }
    .btn-clean { background: #ef4444; color: #fff; }
    .status { text-align: center; margin-top: 15px; padding: 12px; border-radius: 8px; background: rgba(255,255,255,0.05); white-space: pre-line; }
    .alert { background: rgba(239, 68, 68, 0.2); color: #f87171; padding: 12px; border-radius: 8px; margin-bottom: 15px; }
    .alert-title { font-weight: 600; margin-bottom: 8px; }
    .total { text-align: center; font-size: 22px; margin: 15px 0; color: #4ade80; }
    .ext-item { background: rgba(239, 68, 68, 0.1); border-left: 3px solid #f87171; }
    .section { margin-bottom: 20px; }
    .progress-container { margin-top: 15px; display: none; }
    .progress-bar-wrapper {
      width: 100%;
      height: 24px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      border-radius: 12px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 11px;
      font-weight: 500;
    }
    .progress-text {
      text-align: center;
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }
    .section-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .section-progress-container {
      margin-top: 10px;
      display: none;
    }
    /* Tab Navigation */
    .tab-nav {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 4px;
    }
    .tab-btn {
      flex: 1;
      padding: 12px 20px;
      background: transparent;
      color: #888;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .tab-btn.active {
      background: #3b82f6;
      color: #fff;
    }
    .tab-btn:hover:not(.active) {
      background: rgba(255,255,255,0.1);
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    /* Smart Scanner Styles */
    .score-badge {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    .score-high { background: #ef4444; color: #fff; }
    .score-medium { background: #f59e0b; color: #fff; }
    .score-low { background: #22c55e; color: #fff; }
    .reasons-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .reason-tag {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
    }
    .last-accessed {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }
    .filter-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      align-items: center;
      justify-content: center;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .filter-group label {
      font-size: 12px;
      color: #888;
    }
    .filter-group input {
      width: 70px;
      padding: 6px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-size: 12px;
    }
    /* Header & Premium Styles */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .header-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .header-title h1 {
      margin-bottom: 0;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .premium-badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, #facc15, #f97316);
      color: #111827;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .btn-upgrade {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #f97316, #ec4899);
      color: #fff;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(236, 72, 153, 0.35);
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
    }
    .btn-upgrade span {
      font-size: 14px;
    }
    .btn-upgrade:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(236, 72, 153, 0.45);
    }
    .btn-upgrade:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(236, 72, 153, 0.35);
    }
    .btn-upgrade.hidden {
      display: none;
    }
    /* Payment Component Styles */
    .payment-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      padding: 20px;
    }
    .payment-overlay.show {
      display: flex;
    }
    .payment-container {
      background: rgba(17, 24, 39, 0.95);
      border-radius: 18px;
      padding: 24px 26px 20px;
      max-width: 520px;
      width: 100%;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .payment-header {
      text-align: left;
    }
    .payment-title {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .payment-subtitle {
      font-size: 13px;
      color: #9ca3af;
    }
    .payment-status {
      font-size: 13px;
      border-radius: 10px;
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #e5e7eb;
      display: none;
      white-space: pre-line;
    }
    .payment-status.show {
      display: block;
    }
    .payment-status.success {
      border-color: rgba(74, 222, 128, 0.8);
      background: rgba(22, 163, 74, 0.15);
      color: #bbf7d0;
    }
    .payment-status.error {
      border-color: rgba(248, 113, 113, 0.8);
      background: rgba(185, 28, 28, 0.2);
      color: #fecaca;
    }
    .payment-body {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .payment-price {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .payment-price-amount {
      font-size: 32px;
      font-weight: 700;
      color: #4ade80;
    }
    .payment-price-label {
      font-size: 13px;
      color: #9ca3af;
    }
    .payment-steps {
      font-size: 12px;
      color: #9ca3af;
    }
    .payment-steps ol {
      padding-left: 18px;
      margin: 6px 0 0;
    }
    .payment-steps li {
      margin-bottom: 3px;
    }
    .payment-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }
    .payment-field label {
      font-size: 12px;
      color: #e5e7eb;
    }
    .payment-field input {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      font-size: 13px;
    }
    .payment-field input::placeholder {
      color: #6b7280;
    }
    .payment-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 4px;
    }
    .payment-btn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, opacity 0.15s ease, transform 0.1s ease;
    }
    .payment-btn-primary {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #0f172a;
      font-weight: 600;
    }
    .payment-btn-primary:hover:not(:disabled) {
      background: linear-gradient(135deg, #16a34a, #15803d);
      transform: translateY(-1px);
    }
    .payment-btn-secondary {
      background: rgba(31, 41, 55, 0.9);
      color: #e5e7eb;
      border: 1px solid rgba(55, 65, 81, 0.9);
    }
    .payment-btn-secondary:hover:not(:disabled) {
      background: rgba(55, 65, 81, 1);
    }
    .payment-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    @media (max-width: 480px) {
      .payment-container {
        padding: 18px 16px 14px;
      }
      .payment-title {
        font-size: 19px;
      }
      .payment-price-amount {
        font-size: 26px;
      }
      .payment-actions {
        justify-content: center;
      }
    }
    /* AdDisplay Component Styles */
    .ad-display-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .ad-display-overlay.show {
      display: flex;
    }
    .ad-display-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 30px;
      max-width: 90%;
      max-height: 90%;
      width: 600px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    .ad-display-header {
      text-align: center;
      width: 100%;
    }
    .ad-display-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 10px;
      color: #fff;
    }
    .ad-display-subtitle {
      font-size: 14px;
      color: #888;
      margin-bottom: 20px;
    }
    .ad-display-timer {
      font-size: 48px;
      font-weight: 700;
      color: #4ade80;
      margin: 20px 0;
      font-variant-numeric: tabular-nums;
    }
    .ad-display-content {
      width: 100%;
      min-height: 300px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    .ad-display-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      color: #888;
    }
    .ad-display-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .ad-display-error {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      color: #f87171;
      padding: 20px;
      text-align: center;
    }
    .ad-display-error-icon {
      font-size: 48px;
    }
    .ad-display-error-message {
      font-size: 16px;
      margin-bottom: 10px;
    }
    .ad-display-error-details {
      font-size: 12px;
      color: #888;
    }
    .ad-display-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .ad-display-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .ad-display-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .ad-display-btn-retry {
      background: #3b82f6;
      color: #fff;
    }
    .ad-display-btn-retry:hover:not(:disabled) {
      background: #2563eb;
    }
    .ad-display-btn-close {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      display: none;
    }
    .ad-display-btn-close.enabled {
      display: block;
    }
    .ad-display-btn-close:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.2);
    }
    .ad-display-adsense-container {
      width: 100%;
      height: 100%;
      min-height: 300px;
    }
    .ad-display-adsense-container ins {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-title">
    <h1>üßπ Cache Cleaner</h1>
      </div>
      <div class="header-right">
        <span id="premiumBadge" class="premium-badge" style="display:none;">Premium</span>
        <button id="btnUpgrade" class="btn-upgrade">
          <span>‚≠ê</span>
          <span>Upgrade to Premium</span>
        </button>
      </div>
    </div>
    
    <!-- Tab Navigation -->
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="cache-cleaner">üóÇ Cache Cleaner</button>
      <button class="tab-btn" data-tab="smart-scanner">üîç Smart Scanner</button>
    </div>

    <!-- Cache Cleaner Tab -->
    <div id="cache-cleaner-tab" class="tab-content active">
    <div class="total">Total: <span id="totalSize">0 MB</span></div>

    <div id="basicCachesSection" class="section" style="display:none;">
      <h2>üóÇ Editor cache</h2>
      <div id="basicCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBasic">üóë Clear Editor cache</button>
      </div>
      <div id="basicCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="basicCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="basicCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="largeCachesSection" class="section" style="display:none;">
      <h2>üì¶ Large Caches (>1GB)</h2>
      <div id="largeCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanLarge">üóë Clear Large Caches</button>
      </div>
      <div id="largeCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="largeCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="largeCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="indexedDbSection" class="section" style="display:none;">
      <h2>üíæ IndexedDB Origins</h2>
      <div id="indexedDbList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanIndexedDb">üóë Clear IndexedDB</button>
      </div>
      <div id="indexedDbProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="indexedDbProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="indexedDbProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="browserCachesSection" class="section" style="display:none;">
      <h2>üåê Browser Caches</h2>
      <div id="browserCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBrowserCaches">üóë Clear Browser Caches</button>
      </div>
    </div>

    <div id="packageManagersSection" class="section" style="display:none;">
      <h2>üì¶ Package Managers</h2>
      <div id="packageManagersList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanPackageManagers">üóë Clear Package Managers</button>
      </div>
    </div>

    <div id="devToolsSection" class="section" style="display:none;">
      <h2>üîß Development Tools</h2>
      <div id="devToolsList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanDevTools">üóë Clear Dev Tools</button>
      </div>
    </div>

    <div id="systemCachesSection" class="section" style="display:none;">
      <h2>üñ• System Caches</h2>
      <div id="systemCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanSystemCaches">üóë Clear System Caches</button>
      </div>
    </div>

    <div class="actions">
      <button class="btn-scan" id="btnScan">üîç Scan</button>
      <button class="btn-preview" id="btnPreview">üëÅ Preview</button>
      <button class="btn-clean" id="btnClean">üóë Clean Selected</button>
    </div>

    <div id="status" class="status" style="display:none;"></div>
    <div id="progressContainer" class="progress-container">
      <div class="progress-bar-wrapper">
        <div id="progressBar" class="progress-bar" style="width: 0%;">0%</div>
      </div>
      <div id="progressText" class="progress-text"></div>
    </div>
    </div><!-- End Cache Cleaner Tab -->

    <!-- Smart Scanner Tab -->
    <div id="smart-scanner-tab" class="tab-content">
      <div class="total">Smart Suggestions: <span id="smartScannerTotal">0 MB</span></div>
      
      <div class="filter-controls">
        <div class="filter-group">
          <label>Min Size (MB):</label>
          <input type="number" id="minSizeMb" value="100" min="0">
        </div>
        <div class="filter-group">
          <label>Max Age (days):</label>
          <input type="number" id="maxAgeDays" value="30" min="0">
        </div>
      </div>

      <div class="actions">
        <button class="btn-scan" id="btnSmartScan">üîç Scan Suggestions</button>
      </div>

      <div id="smartScannerSection" class="section" style="display:none;">
        <h2>üìÅ Suggested Folders to Clean</h2>
        <div id="smartScannerList" class="cache-list"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanSmartScanner">üóë Delete Selected</button>
        </div>
        <div id="smartScannerProgress" class="section-progress-container">
          <div class="progress-bar-wrapper">
            <div id="smartScannerProgressBar" class="progress-bar" style="width: 0%;">0%</div>
          </div>
          <div id="smartScannerProgressText" class="progress-text"></div>
        </div>
      </div>

      <div id="smartScannerStatus" class="status" style="display:none;">      </div>
    </div><!-- End Smart Scanner Tab -->
  </div>

  <!-- AdDisplay Component -->
  <div id="adDisplayOverlay" class="ad-display-overlay">
    <div class="ad-display-container">
      <div class="ad-display-header">
        <div class="ad-display-title">Advertisement</div>
        <div class="ad-display-subtitle">Please watch this ad to continue</div>
      </div>
      <div class="ad-display-timer" id="adDisplayTimer">15</div>
      <div class="ad-display-content" id="adDisplayContent">
        <div class="ad-display-loading">
          <div class="ad-display-spinner"></div>
          <div>Loading advertisement...</div>
        </div>
      </div>
      <div class="ad-display-actions">
        <button class="ad-display-btn ad-display-btn-retry" id="adDisplayRetry" style="display: none;">Retry</button>
        <button class="ad-display-btn ad-display-btn-close" id="adDisplayClose" disabled>Close</button>
      </div>
    </div>
  </div>

  <!-- PaymentComponent -->
  <div id="paymentOverlay" class="payment-overlay">
    <div class="payment-container">
      <div class="payment-header">
        <div class="payment-title">Upgrade to Premium</div>
        <div class="payment-subtitle">
          One-time purchase ‚Ä¢ Remove ads and unlock unlimited cache cleaning
        </div>
      </div>
      <div id="paymentStatus" class="payment-status"></div>
      <div class="payment-body">
        <div class="payment-price">
          <span class="payment-price-amount">$15</span>
          <span class="payment-price-label">One-time ‚Ä¢ Lifetime access</span>
        </div>
        <div class="payment-steps">
          <strong>How it works:</strong>
          <ol>
            <li>Click <strong>Start Payment</strong> to open secure Paddle checkout.</li>
            <li>Complete the payment in your browser.</li>
            <li>Copy the <strong>Transaction ID</strong> from the receipt.</li>
            <li>Paste it below and click <strong>Confirm Payment</strong>.</li>
          </ol>
        </div>
        <div class="payment-field">
          <label for="transactionIdInput">Transaction ID (from Paddle receipt)</label>
          <input
            id="transactionIdInput"
            type="text"
            placeholder="e.g. txn_123456789"
            autocomplete="off"
          />
        </div>
      </div>
      <div class="payment-actions">
        <button id="paymentStartButton" class="payment-btn payment-btn-primary">
          <span>üí≥</span>
          <span>Start Payment</span>
        </button>
        <button id="paymentConfirmButton" class="payment-btn payment-btn-primary" disabled>
          <span>‚úÖ</span>
          <span>Confirm Payment</span>
        </button>
        <button id="paymentRestoreButton" class="payment-btn payment-btn-secondary">
          <span>üîÑ</span>
          <span>Restore Purchase</span>
        </button>
        <button id="paymentCloseButton" class="payment-btn payment-btn-secondary">
          <span>‚úï</span>
          <span>Close</span>
        </button>
      </div>
    </div>
  </div>

  <script>
    let basicCaches = [];
    let indexedDbItems = [];
    let largeCaches = [];
    let npmCaches = [];
    let browserCaches = [];
    let packageManagers = [];
    let devTools = [];
    let systemCaches = [];
    let smartSuggestions = [];
    let isPremium = false;
    const INDEXED_DB_THRESHOLD_MB = 10;
    let invoke;

    // AdSense Configuration
    const ADSENSE_CONFIG = {
      publisherId: 'ca-pub-PLACEHOLDER', // Replace with your AdSense Publisher ID
      adUnitId: 'ca-app-pub-PLACEHOLDER/PLACEHOLDER', // Replace with your Ad Unit ID
      testAdUnitId: 'ca-app-pub-3940256099942544/5224354917', // Google test ad unit
      environment: 'development', // 'development' or 'production'
      adDurationSeconds: 15
    };

    // Initialize AdSense
    function initAdSense() {
      // Replace placeholder in script tag if needed
      const adScript = document.querySelector('script[src*="adsbygoogle"]');
      if (adScript && ADSENSE_CONFIG.publisherId !== 'ca-pub-PLACEHOLDER') {
        adScript.src = adScript.src.replace('ca-pub-PLACEHOLDER', ADSENSE_CONFIG.publisherId);
      }
      console.log('[AdSense] Initialized with publisher ID:', ADSENSE_CONFIG.publisherId);
    }

    // Premium Status Helpers
    function updatePremiumUI() {
      const badge = document.getElementById('premiumBadge');
      const upgradeBtn = document.getElementById('btnUpgrade');
      if (!badge || !upgradeBtn) return;

      if (isPremium) {
        badge.style.display = 'inline-flex';
        upgradeBtn.classList.add('hidden');
      } else {
        badge.style.display = 'none';
        upgradeBtn.classList.remove('hidden');
      }
    }

    async function refreshPremiumStatus(showErrors = false) {
      if (!window.__TAURI__ || !invoke) return;
      try {
        const status = await invoke('check_premium_status');
        isPremium = !!status;
        console.log('[UI] Premium status:', isPremium);
        updatePremiumUI();
      } catch (e) {
        console.error('[UI] Failed to check premium status:', e);
        if (showErrors) {
          showStatus('Error checking premium status: ' + e);
        }
      }
    }

    // AdDisplay Component
    class AdDisplay {
      constructor() {
        this.overlay = document.getElementById('adDisplayOverlay');
        this.content = document.getElementById('adDisplayContent');
        this.timer = document.getElementById('adDisplayTimer');
        this.retryBtn = document.getElementById('adDisplayRetry');
        this.closeBtn = document.getElementById('adDisplayClose');
        this.currentAdId = null;
        this.timerInterval = null;
        this.remainingSeconds = 0;
        this.isCompleted = false;
        this.onCompleteCallback = null;
        this.onErrorCallback = null;
        
        // Setup event listeners
        this.retryBtn.addEventListener('click', () => this.loadAd());
        this.closeBtn.addEventListener('click', () => this.close());
      }

      async show(onComplete, onError) {
        this.onCompleteCallback = onComplete;
        this.onErrorCallback = onError;
        this.overlay.classList.add('show');
        this.isCompleted = false;
        this.closeBtn.disabled = true;
        this.closeBtn.classList.remove('enabled');
        this.retryBtn.style.display = 'none';
        await this.loadAd();
      }

      async loadAd() {
        try {
          // Show loading state
          this.showLoading();
          
          // Request ad from backend
          if (!invoke) {
            throw new Error('Tauri invoke not available');
          }

          const adRequest = await invoke('request_ad');
          console.log('[AdDisplay] Ad requested:', adRequest);
          
          this.currentAdId = adRequest.ad_id;
          this.remainingSeconds = adRequest.duration_seconds || 15;

          // Load AdSense ad
          await this.loadAdSenseAd(adRequest);
          
          // Start countdown timer
          this.startTimer();
          
        } catch (error) {
          console.error('[AdDisplay] Error loading ad:', error);
          this.showError(error.message || 'Failed to load advertisement');
          if (this.onErrorCallback) {
            this.onErrorCallback(error);
          }
        }
      }

      async loadAdSenseAd(adRequest) {
      return new Promise((resolve, reject) => {
        try {
          const adUnitId = ADSENSE_CONFIG.environment === 'development' 
            ? ADSENSE_CONFIG.testAdUnitId 
              : adRequest.ad_unit_id || ADSENSE_CONFIG.adUnitId;

            console.log('[AdDisplay] Loading AdSense ad with unit ID:', adUnitId);

            // Clear content
            this.content.innerHTML = '';

            // Create ad container
            const adContainer = document.createElement('div');
            adContainer.className = 'ad-display-adsense-container';
            adContainer.id = 'ad-display-adsense-' + Date.now();

          // Create ad element
          const adElement = document.createElement('ins');
          adElement.className = 'adsbygoogle';
          adElement.style.display = 'block';
            adElement.setAttribute('data-ad-client', adRequest.publisher_id || ADSENSE_CONFIG.publisherId);
          adElement.setAttribute('data-ad-slot', adUnitId);
            adElement.setAttribute('data-ad-format', adRequest.format || 'auto');
          adElement.setAttribute('data-full-width-responsive', 'true');

          adContainer.appendChild(adElement);
            this.content.appendChild(adContainer);

          // Push ad to AdSense
          try {
              (window.adsbygoogle = window.adsbygoogle || []).push({});
              console.log('[AdDisplay] Ad pushed to AdSense queue');

              // For testing: simulate ad completion after duration
              // In production, listen to AdSense events
            setTimeout(() => {
                console.log('[AdDisplay] Ad playback completed');
                this.completeAd();
                resolve();
              }, (adRequest.duration_seconds || 15) * 1000);

          } catch (error) {
              console.error('[AdDisplay] Error pushing ad:', error);
            reject(new Error('Failed to load ad: ' + error.message));
          }

        } catch (error) {
            console.error('[AdDisplay] Error creating ad element:', error);
          reject(error);
        }
      });
    }

      showLoading() {
        this.content.innerHTML = `
          <div class="ad-display-loading">
            <div class="ad-display-spinner"></div>
            <div>Loading advertisement...</div>
          </div>
        `;
      }

      showError(message) {
        this.content.innerHTML = `
          <div class="ad-display-error">
            <div class="ad-display-error-icon">‚ö†Ô∏è</div>
            <div class="ad-display-error-message">${message}</div>
            <div class="ad-display-error-details">Please try again or check your connection</div>
          </div>
        `;
        this.retryBtn.style.display = 'block';
        this.timer.textContent = '0';
      }

      startTimer() {
        this.timer.textContent = this.remainingSeconds.toString();
        
        this.timerInterval = setInterval(() => {
          this.remainingSeconds--;
          this.timer.textContent = Math.max(0, this.remainingSeconds).toString();
          
          if (this.remainingSeconds <= 0) {
            this.completeAd();
          }
        }, 1000);
      }

      stopTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      }

      async completeAd() {
        if (this.isCompleted) return;
        
        this.isCompleted = true;
        this.stopTimer();
        this.timer.textContent = '0';
        
        // Notify backend that ad is completed
        try {
          if (this.currentAdId && invoke) {
            await invoke('ad_completed', { ad_id: this.currentAdId });
            console.log('[AdDisplay] Ad completion notified to backend:', this.currentAdId);
          }
        } catch (error) {
          console.error('[AdDisplay] Error notifying ad completion:', error);
          // Continue anyway - ad was watched
        }

        // Enable close button
        this.closeBtn.disabled = false;
        this.closeBtn.classList.add('enabled');
        
        // Call completion callback
        if (this.onCompleteCallback) {
          this.onCompleteCallback();
        }
      }

      close() {
        if (!this.isCompleted) {
          // Prevent closing if ad not completed
          return;
        }
        
        this.overlay.classList.remove('show');
        this.stopTimer();
        this.currentAdId = null;
        this.isCompleted = false;
        this.onCompleteCallback = null;
        this.onErrorCallback = null;
      }
    }

    // Create global AdDisplay instance
    const adDisplay = new AdDisplay();

    // PaymentComponent
    class PaymentComponent {
      constructor() {
        this.overlay = document.getElementById('paymentOverlay');
        this.statusEl = document.getElementById('paymentStatus');
        this.transactionInput = document.getElementById('transactionIdInput');
        this.startButton = document.getElementById('paymentStartButton');
        this.confirmButton = document.getElementById('paymentConfirmButton');
        this.restoreButton = document.getElementById('paymentRestoreButton');
        this.closeButton = document.getElementById('paymentCloseButton');
        this.currentSession = null;
        this.isProcessing = false;

        this.startButton.addEventListener('click', () => this.startPayment());
        this.confirmButton.addEventListener('click', () => this.confirmPayment());
        this.restoreButton.addEventListener('click', () => this.restorePurchase());
        this.closeButton.addEventListener('click', () => this.close());
      }

      show() {
        if (this.overlay) {
          this.overlay.classList.add('show');
        }
        this.clearStatus();
        this.transactionInput.value = '';
        this.confirmButton.disabled = true;
        this.startButton.disabled = false;
        this.isProcessing = false;

        if (isPremium) {
          this.showStatus('You already have premium access. Thank you!', 'success');
          this.startButton.disabled = true;
          this.confirmButton.disabled = true;
        }
      }

      close() {
        if (this.overlay) {
          this.overlay.classList.remove('show');
        }
      }

      setProcessing(isProcessing) {
        this.isProcessing = isProcessing;
        this.startButton.disabled = isProcessing;
        this.confirmButton.disabled = isProcessing || !this.transactionInput.value.trim();
        this.restoreButton.disabled = isProcessing;
        this.closeButton.disabled = isProcessing;
      }

      showStatus(message, type) {
        if (!this.statusEl) return;
        this.statusEl.textContent = message;
        this.statusEl.classList.add('show');
        this.statusEl.classList.remove('success', 'error');
        if (type === 'success') {
          this.statusEl.classList.add('success');
        } else if (type === 'error') {
          this.statusEl.classList.add('error');
        }
      }

      clearStatus() {
        if (!this.statusEl) return;
        this.statusEl.textContent = '';
        this.statusEl.classList.remove('show', 'success', 'error');
      }

      async startPayment() {
        if (!window.__TAURI__ || !invoke) {
          this.showStatus('Tauri API not available. Cannot start payment.', 'error');
          return;
        }

        try {
          this.setProcessing(true);
          this.showStatus('Starting secure checkout session...', null);

          const session = await invoke('initiate_purchase', { amount: 15.0 });
          console.log('[PaymentComponent] Purchase session:', session);
          this.currentSession = session;

          const url = session.checkout_url || session.payment_url;
          if (!url) {
            throw new Error('No checkout URL returned from payment provider');
          }

          try {
            const tauri = window.__TAURI__;
            if (tauri && tauri.shell && typeof tauri.shell.open === 'function') {
              await tauri.shell.open(url);
            } else {
              window.open(url, '_blank', 'noopener,noreferrer');
            }
          } catch (e) {
            console.warn('[PaymentComponent] Failed to open checkout via shell, falling back to window.open', e);
            window.open(url, '_blank', 'noopener,noreferrer');
          }

          this.showStatus(
            'Checkout opened in your browser.\n' +
            'After completing payment, copy the Transaction ID from the receipt\n' +
            'and paste it below, then click "Confirm Payment".',
            null
          );
          this.confirmButton.disabled = false;
        } catch (e) {
          console.error('[PaymentComponent] Failed to start payment:', e);
          this.showStatus('Failed to start payment: ' + e, 'error');
        } finally {
          this.setProcessing(false);
        }
      }

      async confirmPayment() {
        if (!window.__TAURI__ || !invoke) {
          this.showStatus('Tauri API not available. Cannot confirm payment.', 'error');
          return;
        }

        const transactionId = this.transactionInput.value.trim();
        if (!transactionId) {
          this.showStatus('Please enter the Transaction ID from your Paddle receipt.', 'error');
          return;
        }

        try {
          this.setProcessing(true);
          this.showStatus('Verifying payment...', null);

          const receipt = await invoke('process_payment', { transactionId });
          console.log('[PaymentComponent] Payment processed:', receipt);

          this.showStatus('‚úÖ Payment successful! Premium has been activated for this device.', 'success');
          await refreshPremiumStatus(true);
        } catch (e) {
          console.error('[PaymentComponent] Failed to confirm payment:', e);
          this.showStatus('Failed to verify payment: ' + e, 'error');
        } finally {
          this.setProcessing(false);
        }
      }

      async restorePurchase() {
        if (!window.__TAURI__ || !invoke) {
          this.showStatus('Tauri API not available. Cannot restore purchase.', 'error');
          return;
        }

        try {
          this.setProcessing(true);
          this.showStatus('Checking for previous purchases...', null);

          const receipts = await invoke('restore_purchases');
          console.log('[PaymentComponent] Restore purchases result:', receipts);

          if (Array.isArray(receipts) && receipts.length > 0) {
            this.showStatus('‚úÖ Previous purchase restored. Premium has been activated.', 'success');
            await refreshPremiumStatus(true);
          } else {
            this.showStatus('No previous purchases found for this device.', 'error');
          }
        } catch (e) {
          console.error('[PaymentComponent] Failed to restore purchases:', e);
          this.showStatus('Failed to restore purchases: ' + e, 'error');
        } finally {
          this.setProcessing(false);
        }
      }
    }

    // Create global AdDisplay instance
    const paymentComponent = new PaymentComponent();

    // Test ad loading (for development)
    async function testAdLoading() {
      try {
        showStatus('Loading test ad...');
        await adDisplay.show(
          () => {
            showStatus('‚úÖ Test ad completed successfully!');
          },
          (error) => {
        showStatus('‚ùå Ad loading failed: ' + error.message);
          }
        );
      } catch (error) {
        showStatus('‚ùå Ad display error: ' + error.message);
      }
    }

    function getCacheTypeName(type) {
      const names = {
        'npm': 'NPM',
        'chrome': 'Chrome',
        'cachedir': '.cache Directory',
        'cache_dir': '.cache Directory',
        'vscode': 'VSCode',
        'code': 'VSCode',
        'cursor': 'Cursor',
        'safari': 'Safari',
        'firefox': 'Firefox',
        'arc': 'Arc',
        'yarn': 'Yarn',
        'pnpm': 'PNPM',
        'pip': 'Pip',
        'cocoapods': 'CocoaPods',
        'gradle': 'Gradle',
        'cargo': 'Cargo',
        'xcodederiveddata': 'Xcode Derived Data',
        'xcodearchives': 'Xcode Archives',
        'xcodesimulators': 'Xcode Simulators',
        'systemcaches': 'System Caches',
        'userlogs': 'User Logs',
        'tempfiles': 'Temp Files',
        'iosbackups': 'iOS Backups'
      };
      const typeStr = getCacheTypeString(type);
      return names[typeStr.toLowerCase()] || typeStr;
    }

    function getCacheTypeString(type) {
      if (typeof type === 'string') return type;
      return JSON.stringify(type).replace(/"/g, '');
    }

    function formatSize(bytes) {
      if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
      if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes + ' bytes';
    }

    function showStatus(msg) {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideStatus() {
      document.getElementById('status').style.display = 'none';
    }

    function showProgress() {
      document.getElementById('progressContainer').style.display = 'block';
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressBar').textContent = '0%';
      document.getElementById('progressText').textContent = '';
    }

    function updateProgress(percentage, message) {
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const clampedPercentage = Math.min(100, Math.max(0, percentage));
      progressBar.style.width = clampedPercentage + '%';
      progressBar.textContent = Math.round(clampedPercentage) + '%';
      if (message) {
        progressText.textContent = message;
      }
    }

    function hideProgress() {
      document.getElementById('progressContainer').style.display = 'none';
    }

    // Tab Navigation
    function switchTab(tabId) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      document.getElementById(`${tabId}-tab`).classList.add('active');
    }

    // Smart Scanner Functions
    function showSmartScannerStatus(msg) {
      const el = document.getElementById('smartScannerStatus');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideSmartScannerStatus() {
      document.getElementById('smartScannerStatus').style.display = 'none';
    }

    function getScoreBadgeClass(score) {
      if (score >= 0.7) return 'score-high';
      if (score >= 0.4) return 'score-medium';
      return 'score-low';
    }

    function renderSmartScannerFolders() {
      const section = document.getElementById('smartScannerSection');
      const list = document.getElementById('smartScannerList');

      section.style.display = 'block';

      if (!smartSuggestions.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No suggestions found</div></div></div>';
        document.getElementById('btnCleanSmartScanner').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanSmartScanner').style.display = 'block';

      list.innerHTML = smartSuggestions.map((item, i) => `
        <div class="cache-item ${item.score >= 0.7 ? 'ext-item' : ''}">
          <input type="checkbox" id="ss${i}" data-index="${i}" class="ss-checkbox" ${item.score >= 0.5 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">
              ${item.name}
              <span class="score-badge ${getScoreBadgeClass(item.score)}">${Math.round(item.score * 100)}%</span>
            </div>
            <div class="cache-path">${item.path}</div>
            <div class="reasons-tags">
              ${item.reasons.map(r => `<span class="reason-tag">${r}</span>`).join('')}
            </div>
            ${item.last_accessed_days_ago ? `<div class="last-accessed">Last accessed: ${item.last_accessed_days_ago} days ago</div>` : ''}
          </div>
          <div class="cache-size ${item.size_bytes > 1073741824 ? 'large' : ''}">${formatSize(item.size_bytes)}</div>
        </div>
      `).join('');

      updateSmartScannerTotal();
    }

    function updateSmartScannerTotal() {
      const total = smartSuggestions.reduce((sum, s) => sum + s.size_bytes, 0);
      document.getElementById('smartScannerTotal').textContent = formatSize(total);
    }

    function getSelectedSmartSuggestions() {
      return [...document.querySelectorAll('.ss-checkbox:checked')]
        .map(cb => smartSuggestions[parseInt(cb.dataset.index)]);
    }

    async function scanSmartSuggestions() {
      showSmartScannerStatus('Scanning...');
      try {
        const minSizeMb = parseInt(document.getElementById('minSizeMb').value) || 100;
        const maxAgeDays = parseInt(document.getElementById('maxAgeDays').value) || 30;
        
        smartSuggestions = await invoke('scan_smart_suggestions', { minSizeMb, maxAgeDays });
        renderSmartScannerFolders();
        hideSmartScannerStatus();
      } catch (e) {
        showSmartScannerStatus('Error: ' + e);
      }
    }

    async function deleteSmartScannerFolders() {
      const selected = getSelectedSmartSuggestions();
      
      if (!selected.length) {
        showSmartScannerStatus('Select at least one folder');
        return;
      }

      const totalSize = selected.reduce((sum, s) => sum + s.size_bytes, 0);
      let msg = `Are you sure you want to delete ${selected.length} folder(s)?`;
      msg += `\n\n‚ö†Ô∏è WARNING: This will permanently delete ${formatSize(totalSize)} of data.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Deletion',
            kind: 'warning',
            okLabel: 'Yes, Delete',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      const progressContainer = document.getElementById('smartScannerProgress');
      const progressBar = document.getElementById('smartScannerProgressBar');
      const progressText = document.getElementById('smartScannerProgressText');
      progressContainer.style.display = 'block';
      hideSmartScannerStatus();

      try {
        let totalFreed = 0;
        const totalItems = selected.length;

        for (let i = 0; i < selected.length; i++) {
          const item = selected[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          progressBar.style.width = percentage + '%';
          progressBar.textContent = Math.round(percentage) + '%';
          progressText.textContent = `Deleting ${i + 1}/${totalItems} (${item.name})...`;

          const result = await invoke('remove_smart_suggestions', { paths: [item.path] });
          totalFreed += result.total_freed_bytes || 0;
        }

        progressBar.style.width = '100%';
        progressBar.textContent = '100%';
        progressText.textContent = 'Completed!';
        await new Promise(resolve => setTimeout(resolve, 500));
        progressContainer.style.display = 'none';
        showSmartScannerStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanSmartSuggestions();
      } catch (e) {
        progressContainer.style.display = 'none';
        showSmartScannerStatus('Error: ' + e);
      }
    }

    function showSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'block';
        const progressBar = document.getElementById(sectionId + 'ProgressBar');
        const progressText = document.getElementById(sectionId + 'ProgressText');
        if (progressBar) {
          progressBar.style.width = '0%';
          progressBar.textContent = '0%';
        }
        if (progressText) {
          progressText.textContent = '';
        }
      }
    }

    function updateSectionProgress(sectionId, percentage, message) {
      const progressBar = document.getElementById(sectionId + 'ProgressBar');
      const progressText = document.getElementById(sectionId + 'ProgressText');
      if (progressBar) {
        const clampedPercentage = Math.min(100, Math.max(0, percentage));
        progressBar.style.width = clampedPercentage + '%';
        progressBar.textContent = Math.round(clampedPercentage) + '%';
      }
      if (progressText && message) {
        progressText.textContent = message;
      }
    }

    function hideSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'none';
      }
    }

    function renderIndexedDb() {
      const section = document.getElementById('indexedDbSection');
      const list = document.getElementById('indexedDbList');

      section.style.display = 'block';

      if (!indexedDbItems.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No IndexedDB items found (>10MB)</div></div></div>';
        document.getElementById('btnCleanIndexedDb').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanIndexedDb').style.display = 'block';

      list.innerHTML = indexedDbItems.map((item, i) => `
        <div class="cache-item ${item.over_threshold ? 'ext-item' : ''}">
          <input
            type="checkbox"
            id="idb${i}"
            data-index="${i}"
            class="idb-checkbox"
            ${item.over_threshold ? 'checked' : ''}
          >
          <div class="cache-info">
            <div class="cache-name">${item.origin}</div>
            <div class="cache-path">${item.profile} ‚Üí ${item.path}</div>
          </div>
          <div class="cache-size ${item.over_threshold ? 'large' : ''}">${formatSize(item.size)}</div>
        </div>
      `).join('');
    }

    function renderBasicCaches() {
      const section = document.getElementById('basicCachesSection');
      const list = document.getElementById('basicCachesList');

      // Filter to only show editor caches (VSCode and Cursor)
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });

      section.style.display = 'block';

      if (!editorCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No editor caches found</div></div></div>';
        document.getElementById('btnCleanBasic').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBasic').style.display = 'block';

      // Map with original indices for checkbox selection
      let editorIndex = 0;
      list.innerHTML = editorCaches.map((cache) => {
        const originalIndex = basicCaches.findIndex(c => c.cache_type === cache.cache_type && c.path === cache.path);
        const i = editorIndex++;
        return `
        <div class="cache-item">
          <input type="checkbox" id="bc${i}" data-index="${originalIndex}" class="bc-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size ${cache.size > 0 ? '' : ''}">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `;
      }).join('');
    }

    function renderLargeCaches() {
      const section = document.getElementById('largeCachesSection');
      const list = document.getElementById('largeCachesList');

      section.style.display = 'block';

      if (!largeCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No large caches found (>1GB)</div></div></div>';
        document.getElementById('btnCleanLarge').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanLarge').style.display = 'block';

      list.innerHTML = largeCaches.map((cache, i) => `
        <div class="cache-item ext-item">
          <input type="checkbox" id="lc${i}" data-index="${i}" class="lc-checkbox" checked>
          <div class="cache-info">
            <div class="cache-name">${cache.name}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size large">${formatSize(cache.size_bytes)}</div>
        </div>
      `).join('');
    }

    function renderBrowserCaches() {
      const section = document.getElementById('browserCachesSection');
      const list = document.getElementById('browserCachesList');

      section.style.display = 'block';

      if (!browserCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No browser caches found</div></div></div>';
        document.getElementById('btnCleanBrowserCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBrowserCaches').style.display = 'block';

      list.innerHTML = browserCaches.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="browser${i}" data-index="${i}" class="browser-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderPackageManagers() {
      const section = document.getElementById('packageManagersSection');
      const list = document.getElementById('packageManagersList');

      section.style.display = 'block';

      if (!packageManagers.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No package manager caches found</div></div></div>';
        document.getElementById('btnCleanPackageManagers').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanPackageManagers').style.display = 'block';

      list.innerHTML = packageManagers.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="pkg${i}" data-index="${i}" class="pkg-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderDevTools() {
      const section = document.getElementById('devToolsSection');
      const list = document.getElementById('devToolsList');

      section.style.display = 'block';

      if (!devTools.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No development tool caches found</div></div></div>';
        document.getElementById('btnCleanDevTools').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanDevTools').style.display = 'block';

      list.innerHTML = devTools.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="dev${i}" data-index="${i}" class="dev-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderSystemCaches() {
      const section = document.getElementById('systemCachesSection');
      const list = document.getElementById('systemCachesList');

      section.style.display = 'block';

      if (!systemCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No system caches found</div></div></div>';
        document.getElementById('btnCleanSystemCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanSystemCaches').style.display = 'block';

      list.innerHTML = systemCaches.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="sys${i}" data-index="${i}" class="sys-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function updateTotal() {
      // Only count editor caches (VSCode and Cursor) in basicCaches
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });
      const bcTotal = editorCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const browserTotal = browserCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const pkgTotal = packageManagers.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const devTotal = devTools.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const sysTotal = systemCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const idbTotal = indexedDbItems.reduce((sum, i) => sum + i.size, 0);
      const lcTotal = largeCaches.reduce((sum, c) => sum + c.size_bytes, 0);
      document.getElementById('totalSize').textContent = formatSize(bcTotal + browserTotal + pkgTotal + devTotal + sysTotal + idbTotal + lcTotal);
    }

    function getSelectedIndexedDbItems() {
      return [...document.querySelectorAll('.idb-checkbox:checked')]
        .map(cb => indexedDbItems[parseInt(cb.dataset.index)]);
    }

    function getSelectedLargeCaches() {
      return [...document.querySelectorAll('.lc-checkbox:checked')]
        .map(cb => largeCaches[parseInt(cb.dataset.index)]);
    }

    function getSelectedBasicCaches() {
      return [...document.querySelectorAll('.bc-checkbox:checked')]
        .map(cb => basicCaches[parseInt(cb.dataset.index)]);
    }

    async function scanData() {
      showStatus('Scanning...');
      try {
        const allCaches = await invoke('scan_caches');
        
        // Separate caches by category
        basicCaches = allCaches.filter(c => ['vscode', 'code', 'cursor'].includes(c.cache_type.toLowerCase()));
        browserCaches = allCaches.filter(c => ['chrome', 'safari', 'firefox', 'arc'].includes(c.cache_type.toLowerCase()));
        packageManagers = allCaches.filter(c => ['npm', 'yarn', 'pnpm', 'pip', 'cocoapods', 'gradle', 'cargo'].includes(c.cache_type.toLowerCase()));
        devTools = allCaches.filter(c => ['xcodederiveddata', 'xcodearchives', 'xcodesimulators'].includes(c.cache_type.toLowerCase()));
        systemCaches = allCaches.filter(c => ['cachedir', 'systemcaches', 'userlogs', 'tempfiles', 'iosbackups'].includes(c.cache_type.toLowerCase()));
        
        indexedDbItems = await invoke('scan_indexed_db_items', { thresholdMb: INDEXED_DB_THRESHOLD_MB });
        largeCaches = await invoke('scan_large_caches');
        
        // Chrome warning removed - cleaning doesn't affect Chrome
        
        renderBasicCaches();
        renderBrowserCaches();
        renderPackageManagers();
        renderDevTools();
        renderSystemCaches();
        renderIndexedDb();
        renderLargeCaches();
        updateTotal();
        hideStatus();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanBasicCaches() {
      const selectedBc = getSelectedBasicCaches();
      
      if (!selectedBc.length) {
        showStatus('Select at least one editor cache');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected editor caches?';
      const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('basicCaches');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedBc.length;

        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateSectionProgress('basicCaches', percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${totalItems}...`);
          
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          totalFreed += result.freed_bytes || 0;
        }
        
        updateSectionProgress('basicCaches', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('basicCaches');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('basicCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanLargeCaches() {
      const selectedLc = getSelectedLargeCaches();
      
      if (!selectedLc.length) {
        showStatus('Select at least one large cache');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected large caches?';
      const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
      msg += `\n\n‚ö†Ô∏è WARNING: Will delete ${selectedLc.length} large cache directory(ies) from ~/Library/Caches (${formatSize(lcTotal)}).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('largeCaches');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedLc.length;

        for (let i = 0; i < selectedLc.length; i++) {
          const cache = selectedLc[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          updateSectionProgress('largeCaches', percentage, `Cleaning cache ${i + 1}/${totalItems} (${cache.name})...`);
          
          const lcResult = await invoke('remove_large_caches', {
            paths: [cache.path]
          });
          totalFreed += lcResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('largeCaches', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('largeCaches');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('largeCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanIndexedDbItems() {
      const selectedIdb = getSelectedIndexedDbItems();
      
      if (!selectedIdb.length) {
        showStatus('Select at least one IndexedDB item');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected IndexedDB items?';
      msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('indexedDb');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedIdb.length;

        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          updateSectionProgress('indexedDb', percentage, `Cleaning IndexedDB ${i + 1}/${totalItems} (${idbItem.origin})...`);
          
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          totalFreed += idbResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('indexedDb', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('indexedDb');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('indexedDb');
        showStatus('Error: ' + e);
      }
    }

    async function cleanBrowserCaches() {
      const selected = [...document.querySelectorAll('.browser-checkbox:checked')]
        .map(cb => browserCaches[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one browser cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Browser caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanPackageManagers() {
      const selected = [...document.querySelectorAll('.pkg-checkbox:checked')]
        .map(cb => packageManagers[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one package manager cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Package manager caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanDevTools() {
      const selected = [...document.querySelectorAll('.dev-checkbox:checked')]
        .map(cb => devTools[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one dev tool cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Dev tool caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSystemCaches() {
      const selected = [...document.querySelectorAll('.sys-checkbox:checked')]
        .map(cb => systemCaches[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one system cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          const cacheType = getCacheTypeString(cache.cache_type).toLowerCase();
          console.log('[UI] Cleaning system cache:', cacheType);
          await invoke('clean_cache', { cacheType: cacheType, dryRun: false });
        }
        showStatus('‚úÖ System caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function previewClean() {
      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();
      
      if (!selectedBc.length && !selectedIdb.length && !selectedLc.length) { 
        showStatus('Select at least one item'); 
        return; 
      }
      
      showStatus('Previewing...');
      try {
        let results = [];
        
        for (const cache of selectedBc) {
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: true 
          });
          if (result.freed_bytes > 0) {
            const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
            results.push(`${cacheTypeName}: ${formatSize(result.freed_bytes)}`);
          }
        }
        
        if (selectedIdb.length) {
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: selectedIdb.map(i => i.path),
            dryRun: true
          });
          if (idbResult.items_removed) {
            results.push(`IndexedDB (${idbResult.items_removed} origins): ${formatSize(idbResult.total_freed_bytes)}`);
          }
        }

        if (selectedLc.length) {
          const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
          results.push(`Large Caches (${selectedLc.length} directories): ${formatSize(lcTotal)}`);
        }
        
        showStatus('Would free:\n' + results.join('\n'));
      } catch(e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSelected() {
      console.log("[UI] Clean Selected clicked");

      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();

      console.log("[UI] Selected basic caches:", selectedBc);
      console.log("[UI] Selected large caches:", selectedLc);
      
      if (!selectedBc.length && !selectedIdb.length && !selectedLc.length) { 
        console.warn("[UI] No items selected");
        showStatus('Select at least one item'); 
        return; 
      }
      
      let msg = 'Are you sure you want to clean the selected items?';
      if (selectedBc.length) {
        const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;
      }
      if (selectedIdb.length) {
        msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;
      }
      if (selectedLc.length) {
        const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will delete ${selectedLc.length} large cache directory(ies) from ~/Library/Caches (${formatSize(lcTotal)}).`;
      }

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          console.log("[UI] Using Tauri dialog.ask");
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          console.log("[UI] Falling back to window.confirm");
          confirmed = window.confirm(msg);
        } else {
          console.warn("[UI] No confirm dialog available, requiring explicit confirmation");
          showStatus('Error: No dialog available. Please use a browser with confirm support.');
          return;
        }
      } catch (err) {
        console.error("[UI] Error while showing confirm dialog:", err);
        // Fallback to window.confirm if Tauri dialog fails
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      console.log("[UI] Confirm result:", confirmed);
      if (!confirmed) {
        console.log("[UI] User cancelled clean confirmation dialog");
        return;
      }

      // Calculate total items to clean (each item individually)
      const totalItems = selectedBc.length + selectedIdb.length + selectedLc.length;
      let currentItem = 0;

      // Show progress bar
      showProgress();
      hideStatus();
      console.log("[UI] Starting clean operation... Total items:", totalItems);
      
      try {
        let totalFreed = 0;
        
        // Clean basic caches - one by one
        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateProgress(percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${selectedBc.length}...`);
          
          console.log("[UI] Invoking clean_cache for:", cache.cache_type);
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          console.log("[UI] clean_cache result:", result);
          totalFreed += result.freed_bytes || 0;
        }
        
        // Clean IndexedDB - one by one
        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning IndexedDB ${i + 1}/${selectedIdb.length} (${idbItem.origin})...`);
          
          console.log("[UI] Invoking clean_indexed_db_items for origin:", idbItem.origin);
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          console.log("[UI] clean_indexed_db_items result:", idbResult);
          totalFreed += idbResult.total_freed_bytes || 0;
        }

        // Clean large caches - one by one
        for (let i = 0; i < selectedLc.length; i++) {
          const cache = selectedLc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning cache ${i + 1}/${selectedLc.length} (${cache.name})...`);
          
          console.log("[UI] Invoking remove_large_caches for:", cache.path);
          const lcResult = await invoke('remove_large_caches', {
            paths: [cache.path]
          });
          console.log("[UI] remove_large_caches result:", lcResult);
          totalFreed += lcResult.total_freed_bytes || 0;
        }
        
        // Only set 100% after ALL items are actually deleted
        updateProgress(100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to show 100%
        hideProgress();
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        console.log("[UI] Clean operation finished. Total freed bytes:", totalFreed);
        await scanData();
      } catch(e) {
        console.error("[UI] Error during cleanSelected:", e);
        hideProgress();
        showStatus('Error: ' + e);
      }
    }

    function initializeUI() {
      console.log("[UI] Initializing UI");
      initAdSense();
      document.getElementById('btnScan').addEventListener('click', scanData);
      document.getElementById('btnPreview').addEventListener('click', previewClean);
      document.getElementById('btnClean').addEventListener('click', cleanSelected);
      document.getElementById('btnCleanBasic').addEventListener('click', cleanBasicCaches);
      document.getElementById('btnCleanLarge').addEventListener('click', cleanLargeCaches);
      document.getElementById('btnCleanIndexedDb').addEventListener('click', cleanIndexedDbItems);
      document.getElementById('btnCleanBrowserCaches').addEventListener('click', cleanBrowserCaches);
      document.getElementById('btnCleanPackageManagers').addEventListener('click', cleanPackageManagers);
      document.getElementById('btnCleanDevTools').addEventListener('click', cleanDevTools);
      document.getElementById('btnCleanSystemCaches').addEventListener('click', cleanSystemCaches);
      // Tab navigation
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
      });
      // Smart Scanner
      document.getElementById('btnSmartScan').addEventListener('click', scanSmartSuggestions);
      document.getElementById('btnCleanSmartScanner').addEventListener('click', deleteSmartScannerFolders);
      // Upgrade to Premium
      const upgradeBtn = document.getElementById('btnUpgrade');
      if (upgradeBtn) {
        upgradeBtn.addEventListener('click', () => paymentComponent.show());
      }
    }

    // Initialize
    if (window.__TAURI__) {
      console.log("[UI] Tauri detected, initializing immediately");
      invoke = window.__TAURI__.core.invoke;
      initializeUI();
      refreshPremiumStatus(false);
      scanData();
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (window.__TAURI__) {
            console.log("[UI] Tauri became available after DOMContentLoaded");
            invoke = window.__TAURI__.core.invoke;
            initializeUI();
            refreshPremiumStatus(false);
            scanData();
          } else {
            showStatus('Tauri API not available');
          }
        }, 100);
      });
    }
  </script>
</body>
</html>
