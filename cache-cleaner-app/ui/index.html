<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Cleaner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 20px; font-weight: 300; }
    h2 { font-size: 16px; margin: 20px 0 10px; color: #888; }
    .cache-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .cache-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cache-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .cache-info { flex: 1; }
    .cache-name { font-weight: 500; font-size: 15px; }
    .cache-path { font-size: 11px; color: #888; margin-top: 3px; word-break: break-all; }
    .cache-size { font-size: 14px; color: #4ade80; font-weight: 500; }
    .cache-size.large { color: #f87171; }
    .actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-scan { background: #3b82f6; color: #fff; }
    .btn-preview { background: #8b5cf6; color: #fff; }
    .btn-clean { background: #ef4444; color: #fff; }
    .status { text-align: center; margin-top: 15px; padding: 12px; border-radius: 8px; background: rgba(255,255,255,0.05); white-space: pre-line; }
    .warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; padding: 12px; border-radius: 8px; margin-bottom: 15px; text-align: center; }
    .alert { background: rgba(239, 68, 68, 0.2); color: #f87171; padding: 12px; border-radius: 8px; margin-bottom: 15px; }
    .alert-title { font-weight: 600; margin-bottom: 8px; }
    .total { text-align: center; font-size: 22px; margin: 15px 0; color: #4ade80; }
    .ext-item { background: rgba(239, 68, 68, 0.1); border-left: 3px solid #f87171; }
    .section { margin-bottom: 20px; }
    .progress-container { margin-top: 15px; display: none; }
    .progress-bar-wrapper {
      width: 100%;
      height: 24px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      border-radius: 12px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 11px;
      font-weight: 500;
    }
    .progress-text {
      text-align: center;
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßπ Cache Cleaner</h1>
    
    <div id="warning" class="warning" style="display:none;">
      ‚ö†Ô∏è Chrome is running. Close it before cleaning Chrome data.
    </div>

    <div class="total">Total: <span id="totalSize">0 MB</span></div>

    <div id="largeCachesSection" class="section" style="display:none;">
      <h2>üì¶ Large Caches (>1GB)</h2>
      <div id="largeCachesList" class="cache-list"></div>
    </div>

    <div id="indexedDbSection" class="section" style="display:none;">
      <h2>üíæ IndexedDB Origins</h2>
      <div id="indexedDbList" class="cache-list"></div>
    </div>

    <div id="extSection" class="section" style="display:none;">
      <h2>üß© Large Extensions (>100MB)</h2>
      <div id="extList" class="cache-list"></div>
    </div>

    <div class="actions">
      <button class="btn-scan" id="btnScan">üîç Scan</button>
      <button class="btn-preview" id="btnPreview">üëÅ Preview</button>
      <button class="btn-clean" id="btnClean">üóë Clean Selected</button>
    </div>

    <div id="status" class="status" style="display:none;"></div>
    <div id="progressContainer" class="progress-container">
      <div class="progress-bar-wrapper">
        <div id="progressBar" class="progress-bar" style="width: 0%;">0%</div>
      </div>
      <div id="progressText" class="progress-text"></div>
    </div>
  </div>

  <script>
    let extensions = [];
    let indexedDbItems = [];
    let largeCaches = [];
    const INDEXED_DB_THRESHOLD_MB = 10;
    let invoke;

    function formatSize(bytes) {
      if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
      if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes + ' bytes';
    }

    function showStatus(msg) {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideStatus() {
      document.getElementById('status').style.display = 'none';
    }

    function showProgress() {
      document.getElementById('progressContainer').style.display = 'block';
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressBar').textContent = '0%';
      document.getElementById('progressText').textContent = '';
    }

    function updateProgress(percentage, message) {
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const clampedPercentage = Math.min(100, Math.max(0, percentage));
      progressBar.style.width = clampedPercentage + '%';
      progressBar.textContent = Math.round(clampedPercentage) + '%';
      if (message) {
        progressText.textContent = message;
      }
    }

    function hideProgress() {
      document.getElementById('progressContainer').style.display = 'none';
    }

    function renderExtensions() {
      const section = document.getElementById('extSection');
      const list = document.getElementById('extList');

      if (!extensions.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      // Store index to reference extensions array
      list.innerHTML = extensions.map((e, i) => `
        <div class="cache-item ext-item">
          <input type="checkbox" id="ext${i}" data-index="${i}" class="ext-checkbox">
          <div class="cache-info">
            <div class="cache-name">${e.id.substring(0, 32)}...</div>
            <div class="cache-path">${e.profile} ‚Üí ${e.path}</div>
          </div>
          <div class="cache-size large">${formatSize(e.size)}</div>
        </div>
      `).join('');
    }

    function renderIndexedDb() {
      const section = document.getElementById('indexedDbSection');
      const list = document.getElementById('indexedDbList');

      if (!indexedDbItems.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      list.innerHTML = indexedDbItems.map((item, i) => `
        <div class="cache-item ${item.over_threshold ? 'ext-item' : ''}">
          <input
            type="checkbox"
            id="idb${i}"
            data-index="${i}"
            class="idb-checkbox"
            ${item.over_threshold ? 'checked' : ''}
          >
          <div class="cache-info">
            <div class="cache-name">${item.origin}</div>
            <div class="cache-path">${item.profile} ‚Üí ${item.path}</div>
          </div>
          <div class="cache-size ${item.over_threshold ? 'large' : ''}">${formatSize(item.size)}</div>
        </div>
      `).join('');
    }

    function renderLargeCaches() {
      const section = document.getElementById('largeCachesSection');
      const list = document.getElementById('largeCachesList');

      if (!largeCaches.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      list.innerHTML = largeCaches.map((cache, i) => `
        <div class="cache-item ext-item">
          <input type="checkbox" id="lc${i}" data-index="${i}" class="lc-checkbox" checked>
          <div class="cache-info">
            <div class="cache-name">${cache.name}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size large">${formatSize(cache.size_bytes)}</div>
        </div>
      `).join('');
    }

    function updateTotal() {
      const extTotal = extensions.reduce((sum, e) => sum + e.size, 0);
      const idbTotal = indexedDbItems.reduce((sum, i) => sum + i.size, 0);
      const lcTotal = largeCaches.reduce((sum, c) => sum + c.size_bytes, 0);
      document.getElementById('totalSize').textContent = formatSize(extTotal + idbTotal + lcTotal);
    }

    function getSelectedExtensions() {
      return [...document.querySelectorAll('.ext-checkbox:checked')]
        .map(cb => extensions[parseInt(cb.dataset.index)]);
    }

    function getSelectedIndexedDbItems() {
      return [...document.querySelectorAll('.idb-checkbox:checked')]
        .map(cb => indexedDbItems[parseInt(cb.dataset.index)]);
    }

    function getSelectedLargeCaches() {
      return [...document.querySelectorAll('.lc-checkbox:checked')]
        .map(cb => largeCaches[parseInt(cb.dataset.index)]);
    }

    async function scanData() {
      showStatus('Scanning...');
      try {
        extensions = await invoke('scan_large_extensions', { thresholdMb: 10 });
        indexedDbItems = await invoke('scan_indexed_db_items', { thresholdMb: INDEXED_DB_THRESHOLD_MB });
        largeCaches = await invoke('scan_large_caches');
        
        try {
          const chromeRunning = await invoke('check_chrome_running');
          document.getElementById('warning').style.display = chromeRunning ? 'block' : 'none';
        } catch(e) {}
        
        renderExtensions();
        renderIndexedDb();
        renderLargeCaches();
        updateTotal();
        hideStatus();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function previewClean() {
      const selectedExts = getSelectedExtensions();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();
      
      if (!selectedExts.length && !selectedIdb.length && !selectedLc.length) { 
        showStatus('Select at least one item'); 
        return; 
      }
      
      showStatus('Previewing...');
      try {
        let results = [];
        
        for (const ext of selectedExts) {
          const result = await invoke('delete_extension', { path: ext.path, dryRun: true });
          results.push(`Extension ${ext.id.substring(0,16)}...: ${formatSize(result.freed_bytes)}`);
        }

        if (selectedIdb.length) {
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: selectedIdb.map(i => i.path),
            dryRun: true
          });
          if (idbResult.items_removed) {
            results.push(`IndexedDB (${idbResult.items_removed} origins): ${formatSize(idbResult.total_freed_bytes)}`);
          }
        }

        if (selectedLc.length) {
          const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
          results.push(`Large Caches (${selectedLc.length} directories): ${formatSize(lcTotal)}`);
        }
        
        showStatus('Would free:\n' + results.join('\n'));
      } catch(e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSelected() {
      console.log("[UI] Clean Selected clicked");

      const selectedExts = getSelectedExtensions();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();

      console.log("[UI] Selected extensions:", selectedExts);
      console.log("[UI] Selected large caches:", selectedLc);
      
      if (!selectedExts.length && !selectedIdb.length && !selectedLc.length) { 
        console.warn("[UI] No items selected");
        showStatus('Select at least one item'); 
        return; 
      }
      
      let msg = 'Are you sure you want to clean the selected items?';
      if (selectedExts.length) {
        msg += '\n\n‚ö†Ô∏è WARNING: Deleting extensions will remove them from Chrome!';
      }
      if (selectedIdb.length) {
        msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;
      }
      if (selectedLc.length) {
        const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will delete ${selectedLc.length} large cache directory(ies) from ~/Library/Caches (${formatSize(lcTotal)}).`;
      }

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          console.log("[UI] Using Tauri dialog.ask");
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          console.log("[UI] Falling back to window.confirm");
          confirmed = window.confirm(msg);
        } else {
          console.warn("[UI] No confirm dialog available, requiring explicit confirmation");
          showStatus('Error: No dialog available. Please use a browser with confirm support.');
          return;
        }
      } catch (err) {
        console.error("[UI] Error while showing confirm dialog:", err);
        // Fallback to window.confirm if Tauri dialog fails
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      console.log("[UI] Confirm result:", confirmed);
      if (!confirmed) {
        console.log("[UI] User cancelled clean confirmation dialog");
        return;
      }

      // Calculate total items to clean (each item individually)
      const totalItems = selectedExts.length + selectedIdb.length + selectedLc.length;
      let currentItem = 0;

      // Show progress bar
      showProgress();
      hideStatus();
      console.log("[UI] Starting clean operation... Total items:", totalItems);
      
      try {
        let totalFreed = 0;
        
        // Clean extensions - one by one
        for (let i = 0; i < selectedExts.length; i++) {
          const ext = selectedExts[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100); // Max 99% until all done
          updateProgress(percentage, `Cleaning extension ${i + 1}/${selectedExts.length}...`);
          
          console.log("[UI] Invoking delete_extension for path:", ext.path);
          const result = await invoke('delete_extension', { path: ext.path, dryRun: false });
          console.log("[UI] delete_extension result for", ext.path, ":", result);
          totalFreed += result.freed_bytes || 0;
        }

        // Clean IndexedDB - one by one
        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning IndexedDB ${i + 1}/${selectedIdb.length} (${idbItem.origin})...`);
          
          console.log("[UI] Invoking clean_indexed_db_items for origin:", idbItem.origin);
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          console.log("[UI] clean_indexed_db_items result:", idbResult);
          totalFreed += idbResult.total_freed_bytes || 0;
        }

        // Clean large caches - one by one
        for (let i = 0; i < selectedLc.length; i++) {
          const cache = selectedLc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning cache ${i + 1}/${selectedLc.length} (${cache.name})...`);
          
          console.log("[UI] Invoking remove_large_caches for:", cache.path);
          const lcResult = await invoke('remove_large_caches', {
            paths: [cache.path]
          });
          console.log("[UI] remove_large_caches result:", lcResult);
          totalFreed += lcResult.total_freed_bytes || 0;
        }
        
        // Only set 100% after ALL items are actually deleted
        updateProgress(100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to show 100%
        hideProgress();
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        console.log("[UI] Clean operation finished. Total freed bytes:", totalFreed);
        await scanData();
      } catch(e) {
        console.error("[UI] Error during cleanSelected:", e);
        hideProgress();
        showStatus('Error: ' + e);
      }
    }

    // Initialize
    if (window.__TAURI__) {
      console.log("[UI] Tauri detected, initializing immediately");
      invoke = window.__TAURI__.core.invoke;
      document.getElementById('btnScan').addEventListener('click', scanData);
      document.getElementById('btnPreview').addEventListener('click', previewClean);
      document.getElementById('btnClean').addEventListener('click', cleanSelected);
      scanData();
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (window.__TAURI__) {
            console.log("[UI] Tauri became available after DOMContentLoaded");
            invoke = window.__TAURI__.core.invoke;
            document.getElementById('btnScan').addEventListener('click', scanData);
            document.getElementById('btnPreview').addEventListener('click', previewClean);
            document.getElementById('btnClean').addEventListener('click', cleanSelected);
            scanData();
          } else {
            showStatus('Tauri API not available');
          }
        }, 100);
      });
    }
  </script>
</body>
</html>
