<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Cleaner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 20px; font-weight: 300; }
    h2 { font-size: 16px; margin: 20px 0 10px; color: #888; }
    .cache-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .cache-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cache-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .cache-info { flex: 1; }
    .cache-name { font-weight: 500; font-size: 15px; }
    .cache-path { font-size: 11px; color: #888; margin-top: 3px; word-break: break-all; }
    .cache-size { font-size: 14px; color: #4ade80; font-weight: 500; }
    .cache-size.large { color: #f87171; }
    .actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-scan { background: #3b82f6; color: #fff; }
    .btn-preview { background: #8b5cf6; color: #fff; }
    .btn-clean { background: #ef4444; color: #fff; }
    .status { text-align: center; margin-top: 15px; padding: 12px; border-radius: 8px; background: rgba(255,255,255,0.05); white-space: pre-line; }
    .alert { background: rgba(239, 68, 68, 0.2); color: #f87171; padding: 12px; border-radius: 8px; margin-bottom: 15px; }
    .alert-title { font-weight: 600; margin-bottom: 8px; }
    .total { text-align: center; font-size: 22px; margin: 15px 0; color: #4ade80; }
    .ext-item { background: rgba(239, 68, 68, 0.1); border-left: 3px solid #f87171; }
    .section { margin-bottom: 20px; }
    .progress-container { margin-top: 15px; display: none; }
    .progress-bar-wrapper {
      width: 100%;
      height: 24px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      border-radius: 12px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 11px;
      font-weight: 500;
    }
    .progress-text {
      text-align: center;
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }
    .section-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .section-progress-container {
      margin-top: 10px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßπ Cache Cleaner</h1>
    
    <div class="total">Total: <span id="totalSize">0 MB</span></div>

    <div id="basicCachesSection" class="section" style="display:none;">
      <h2>üóÇ Editor cache</h2>
      <div id="basicCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBasic">üóë Clear Editor cache</button>
      </div>
      <div id="basicCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="basicCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="basicCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="largeCachesSection" class="section" style="display:none;">
      <h2>üì¶ Large Caches (>1GB)</h2>
      <div id="largeCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanLarge">üóë Clear Large Caches</button>
      </div>
      <div id="largeCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="largeCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="largeCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="indexedDbSection" class="section" style="display:none;">
      <h2>üíæ IndexedDB Origins</h2>
      <div id="indexedDbList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanIndexedDb">üóë Clear IndexedDB</button>
      </div>
      <div id="indexedDbProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="indexedDbProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="indexedDbProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="browserCachesSection" class="section" style="display:none;">
      <h2>üåê Browser Caches</h2>
      <div id="browserCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBrowserCaches">üóë Clear Browser Caches</button>
      </div>
    </div>

    <div id="packageManagersSection" class="section" style="display:none;">
      <h2>üì¶ Package Managers</h2>
      <div id="packageManagersList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanPackageManagers">üóë Clear Package Managers</button>
      </div>
    </div>

    <div id="devToolsSection" class="section" style="display:none;">
      <h2>üîß Development Tools</h2>
      <div id="devToolsList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanDevTools">üóë Clear Dev Tools</button>
      </div>
    </div>

    <div id="systemCachesSection" class="section" style="display:none;">
      <h2>üñ• System Caches</h2>
      <div id="systemCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanSystemCaches">üóë Clear System Caches</button>
      </div>
    </div>

    <div class="actions">
      <button class="btn-scan" id="btnScan">üîç Scan</button>
      <button class="btn-preview" id="btnPreview">üëÅ Preview</button>
      <button class="btn-clean" id="btnClean">üóë Clean Selected</button>
    </div>

    <div id="status" class="status" style="display:none;"></div>
    <div id="progressContainer" class="progress-container">
      <div class="progress-bar-wrapper">
        <div id="progressBar" class="progress-bar" style="width: 0%;">0%</div>
      </div>
      <div id="progressText" class="progress-text"></div>
    </div>
  </div>

  <script>
    let basicCaches = [];
    let indexedDbItems = [];
    let largeCaches = [];
    let npmCaches = [];
    let browserCaches = [];
    let packageManagers = [];
    let devTools = [];
    let systemCaches = [];
    const INDEXED_DB_THRESHOLD_MB = 10;
    let invoke;

    function getCacheTypeName(type) {
      const names = {
        'npm': 'NPM',
        'chrome': 'Chrome',
        'cachedir': '.cache Directory',
        'cache_dir': '.cache Directory',
        'vscode': 'VSCode',
        'code': 'VSCode',
        'cursor': 'Cursor',
        'safari': 'Safari',
        'firefox': 'Firefox',
        'arc': 'Arc',
        'yarn': 'Yarn',
        'pnpm': 'PNPM',
        'pip': 'Pip',
        'cocoapods': 'CocoaPods',
        'gradle': 'Gradle',
        'cargo': 'Cargo',
        'xcodederiveddata': 'Xcode Derived Data',
        'xcodearchives': 'Xcode Archives',
        'xcodesimulators': 'Xcode Simulators',
        'systemcaches': 'System Caches',
        'userlogs': 'User Logs',
        'tempfiles': 'Temp Files',
        'iosbackups': 'iOS Backups'
      };
      const typeStr = getCacheTypeString(type);
      return names[typeStr.toLowerCase()] || typeStr;
    }

    function getCacheTypeString(type) {
      if (typeof type === 'string') return type;
      return JSON.stringify(type).replace(/"/g, '');
    }

    function formatSize(bytes) {
      if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
      if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes + ' bytes';
    }

    function showStatus(msg) {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideStatus() {
      document.getElementById('status').style.display = 'none';
    }

    function showProgress() {
      document.getElementById('progressContainer').style.display = 'block';
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressBar').textContent = '0%';
      document.getElementById('progressText').textContent = '';
    }

    function updateProgress(percentage, message) {
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const clampedPercentage = Math.min(100, Math.max(0, percentage));
      progressBar.style.width = clampedPercentage + '%';
      progressBar.textContent = Math.round(clampedPercentage) + '%';
      if (message) {
        progressText.textContent = message;
      }
    }

    function hideProgress() {
      document.getElementById('progressContainer').style.display = 'none';
    }

    function showSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'block';
        const progressBar = document.getElementById(sectionId + 'ProgressBar');
        const progressText = document.getElementById(sectionId + 'ProgressText');
        if (progressBar) {
          progressBar.style.width = '0%';
          progressBar.textContent = '0%';
        }
        if (progressText) {
          progressText.textContent = '';
        }
      }
    }

    function updateSectionProgress(sectionId, percentage, message) {
      const progressBar = document.getElementById(sectionId + 'ProgressBar');
      const progressText = document.getElementById(sectionId + 'ProgressText');
      if (progressBar) {
        const clampedPercentage = Math.min(100, Math.max(0, percentage));
        progressBar.style.width = clampedPercentage + '%';
        progressBar.textContent = Math.round(clampedPercentage) + '%';
      }
      if (progressText && message) {
        progressText.textContent = message;
      }
    }

    function hideSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'none';
      }
    }

    function renderIndexedDb() {
      const section = document.getElementById('indexedDbSection');
      const list = document.getElementById('indexedDbList');

      section.style.display = 'block';

      if (!indexedDbItems.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No IndexedDB items found (>10MB)</div></div></div>';
        document.getElementById('btnCleanIndexedDb').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanIndexedDb').style.display = 'block';

      list.innerHTML = indexedDbItems.map((item, i) => `
        <div class="cache-item ${item.over_threshold ? 'ext-item' : ''}">
          <input
            type="checkbox"
            id="idb${i}"
            data-index="${i}"
            class="idb-checkbox"
            ${item.over_threshold ? 'checked' : ''}
          >
          <div class="cache-info">
            <div class="cache-name">${item.origin}</div>
            <div class="cache-path">${item.profile} ‚Üí ${item.path}</div>
          </div>
          <div class="cache-size ${item.over_threshold ? 'large' : ''}">${formatSize(item.size)}</div>
        </div>
      `).join('');
    }

    function renderBasicCaches() {
      const section = document.getElementById('basicCachesSection');
      const list = document.getElementById('basicCachesList');

      // Filter to only show editor caches (VSCode and Cursor)
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });

      section.style.display = 'block';

      if (!editorCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No editor caches found</div></div></div>';
        document.getElementById('btnCleanBasic').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBasic').style.display = 'block';

      // Map with original indices for checkbox selection
      let editorIndex = 0;
      list.innerHTML = editorCaches.map((cache) => {
        const originalIndex = basicCaches.findIndex(c => c.cache_type === cache.cache_type && c.path === cache.path);
        const i = editorIndex++;
        return `
        <div class="cache-item">
          <input type="checkbox" id="bc${i}" data-index="${originalIndex}" class="bc-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size ${cache.size > 0 ? '' : ''}">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `;
      }).join('');
    }

    function renderLargeCaches() {
      const section = document.getElementById('largeCachesSection');
      const list = document.getElementById('largeCachesList');

      section.style.display = 'block';

      if (!largeCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No large caches found (>1GB)</div></div></div>';
        document.getElementById('btnCleanLarge').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanLarge').style.display = 'block';

      list.innerHTML = largeCaches.map((cache, i) => `
        <div class="cache-item ext-item">
          <input type="checkbox" id="lc${i}" data-index="${i}" class="lc-checkbox" checked>
          <div class="cache-info">
            <div class="cache-name">${cache.name}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size large">${formatSize(cache.size_bytes)}</div>
        </div>
      `).join('');
    }

    function renderBrowserCaches() {
      const section = document.getElementById('browserCachesSection');
      const list = document.getElementById('browserCachesList');

      section.style.display = 'block';

      if (!browserCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No browser caches found</div></div></div>';
        document.getElementById('btnCleanBrowserCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBrowserCaches').style.display = 'block';

      list.innerHTML = browserCaches.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="browser${i}" data-index="${i}" class="browser-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderPackageManagers() {
      const section = document.getElementById('packageManagersSection');
      const list = document.getElementById('packageManagersList');

      section.style.display = 'block';

      if (!packageManagers.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No package manager caches found</div></div></div>';
        document.getElementById('btnCleanPackageManagers').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanPackageManagers').style.display = 'block';

      list.innerHTML = packageManagers.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="pkg${i}" data-index="${i}" class="pkg-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderDevTools() {
      const section = document.getElementById('devToolsSection');
      const list = document.getElementById('devToolsList');

      section.style.display = 'block';

      if (!devTools.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No development tool caches found</div></div></div>';
        document.getElementById('btnCleanDevTools').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanDevTools').style.display = 'block';

      list.innerHTML = devTools.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="dev${i}" data-index="${i}" class="dev-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderSystemCaches() {
      const section = document.getElementById('systemCachesSection');
      const list = document.getElementById('systemCachesList');

      section.style.display = 'block';

      if (!systemCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No system caches found</div></div></div>';
        document.getElementById('btnCleanSystemCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanSystemCaches').style.display = 'block';

      list.innerHTML = systemCaches.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="sys${i}" data-index="${i}" class="sys-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            <div class="cache-path">${cache.path}</div>
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function updateTotal() {
      // Only count editor caches (VSCode and Cursor) in basicCaches
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });
      const bcTotal = editorCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const browserTotal = browserCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const pkgTotal = packageManagers.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const devTotal = devTools.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const sysTotal = systemCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const idbTotal = indexedDbItems.reduce((sum, i) => sum + i.size, 0);
      const lcTotal = largeCaches.reduce((sum, c) => sum + c.size_bytes, 0);
      document.getElementById('totalSize').textContent = formatSize(bcTotal + browserTotal + pkgTotal + devTotal + sysTotal + idbTotal + lcTotal);
    }

    function getSelectedIndexedDbItems() {
      return [...document.querySelectorAll('.idb-checkbox:checked')]
        .map(cb => indexedDbItems[parseInt(cb.dataset.index)]);
    }

    function getSelectedLargeCaches() {
      return [...document.querySelectorAll('.lc-checkbox:checked')]
        .map(cb => largeCaches[parseInt(cb.dataset.index)]);
    }

    function getSelectedBasicCaches() {
      return [...document.querySelectorAll('.bc-checkbox:checked')]
        .map(cb => basicCaches[parseInt(cb.dataset.index)]);
    }

    async function scanData() {
      showStatus('Scanning...');
      try {
        const allCaches = await invoke('scan_caches');
        
        // Separate caches by category
        basicCaches = allCaches.filter(c => ['vscode', 'code', 'cursor'].includes(c.cache_type.toLowerCase()));
        browserCaches = allCaches.filter(c => ['chrome', 'safari', 'firefox', 'arc'].includes(c.cache_type.toLowerCase()));
        packageManagers = allCaches.filter(c => ['npm', 'yarn', 'pnpm', 'pip', 'cocoapods', 'gradle', 'cargo'].includes(c.cache_type.toLowerCase()));
        devTools = allCaches.filter(c => ['xcodederiveddata', 'xcodearchives', 'xcodesimulators'].includes(c.cache_type.toLowerCase()));
        systemCaches = allCaches.filter(c => ['cachedir', 'systemcaches', 'userlogs', 'tempfiles', 'iosbackups'].includes(c.cache_type.toLowerCase()));
        
        indexedDbItems = await invoke('scan_indexed_db_items', { thresholdMb: INDEXED_DB_THRESHOLD_MB });
        largeCaches = await invoke('scan_large_caches');
        
        // Chrome warning removed - cleaning doesn't affect Chrome
        
        renderBasicCaches();
        renderBrowserCaches();
        renderPackageManagers();
        renderDevTools();
        renderSystemCaches();
        renderIndexedDb();
        renderLargeCaches();
        updateTotal();
        hideStatus();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanBasicCaches() {
      const selectedBc = getSelectedBasicCaches();
      
      if (!selectedBc.length) {
        showStatus('Select at least one editor cache');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected editor caches?';
      const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('basicCaches');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedBc.length;

        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateSectionProgress('basicCaches', percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${totalItems}...`);
          
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          totalFreed += result.freed_bytes || 0;
        }
        
        updateSectionProgress('basicCaches', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('basicCaches');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('basicCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanLargeCaches() {
      const selectedLc = getSelectedLargeCaches();
      
      if (!selectedLc.length) {
        showStatus('Select at least one large cache');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected large caches?';
      const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
      msg += `\n\n‚ö†Ô∏è WARNING: Will delete ${selectedLc.length} large cache directory(ies) from ~/Library/Caches (${formatSize(lcTotal)}).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('largeCaches');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedLc.length;

        for (let i = 0; i < selectedLc.length; i++) {
          const cache = selectedLc[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          updateSectionProgress('largeCaches', percentage, `Cleaning cache ${i + 1}/${totalItems} (${cache.name})...`);
          
          const lcResult = await invoke('remove_large_caches', {
            paths: [cache.path]
          });
          totalFreed += lcResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('largeCaches', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('largeCaches');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('largeCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanIndexedDbItems() {
      const selectedIdb = getSelectedIndexedDbItems();
      
      if (!selectedIdb.length) {
        showStatus('Select at least one IndexedDB item');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected IndexedDB items?';
      msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('indexedDb');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedIdb.length;

        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          updateSectionProgress('indexedDb', percentage, `Cleaning IndexedDB ${i + 1}/${totalItems} (${idbItem.origin})...`);
          
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          totalFreed += idbResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('indexedDb', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('indexedDb');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('indexedDb');
        showStatus('Error: ' + e);
      }
    }

    async function cleanBrowserCaches() {
      const selected = [...document.querySelectorAll('.browser-checkbox:checked')]
        .map(cb => browserCaches[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one browser cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Browser caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanPackageManagers() {
      const selected = [...document.querySelectorAll('.pkg-checkbox:checked')]
        .map(cb => packageManagers[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one package manager cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Package manager caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanDevTools() {
      const selected = [...document.querySelectorAll('.dev-checkbox:checked')]
        .map(cb => devTools[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one dev tool cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Dev tool caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSystemCaches() {
      const selected = [...document.querySelectorAll('.sys-checkbox:checked')]
        .map(cb => systemCaches[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one system cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          const cacheType = getCacheTypeString(cache.cache_type).toLowerCase();
          console.log('[UI] Cleaning system cache:', cacheType);
          await invoke('clean_cache', { cacheType: cacheType, dryRun: false });
        }
        showStatus('‚úÖ System caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function previewClean() {
      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();
      
      if (!selectedBc.length && !selectedIdb.length && !selectedLc.length) { 
        showStatus('Select at least one item'); 
        return; 
      }
      
      showStatus('Previewing...');
      try {
        let results = [];
        
        for (const cache of selectedBc) {
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: true 
          });
          if (result.freed_bytes > 0) {
            const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
            results.push(`${cacheTypeName}: ${formatSize(result.freed_bytes)}`);
          }
        }
        
        if (selectedIdb.length) {
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: selectedIdb.map(i => i.path),
            dryRun: true
          });
          if (idbResult.items_removed) {
            results.push(`IndexedDB (${idbResult.items_removed} origins): ${formatSize(idbResult.total_freed_bytes)}`);
          }
        }

        if (selectedLc.length) {
          const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
          results.push(`Large Caches (${selectedLc.length} directories): ${formatSize(lcTotal)}`);
        }
        
        showStatus('Would free:\n' + results.join('\n'));
      } catch(e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSelected() {
      console.log("[UI] Clean Selected clicked");

      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();
      const selectedLc = getSelectedLargeCaches();

      console.log("[UI] Selected basic caches:", selectedBc);
      console.log("[UI] Selected large caches:", selectedLc);
      
      if (!selectedBc.length && !selectedIdb.length && !selectedLc.length) { 
        console.warn("[UI] No items selected");
        showStatus('Select at least one item'); 
        return; 
      }
      
      let msg = 'Are you sure you want to clean the selected items?';
      if (selectedBc.length) {
        const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;
      }
      if (selectedIdb.length) {
        msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;
      }
      if (selectedLc.length) {
        const lcTotal = selectedLc.reduce((sum, c) => sum + c.size_bytes, 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will delete ${selectedLc.length} large cache directory(ies) from ~/Library/Caches (${formatSize(lcTotal)}).`;
      }

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          console.log("[UI] Using Tauri dialog.ask");
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          console.log("[UI] Falling back to window.confirm");
          confirmed = window.confirm(msg);
        } else {
          console.warn("[UI] No confirm dialog available, requiring explicit confirmation");
          showStatus('Error: No dialog available. Please use a browser with confirm support.');
          return;
        }
      } catch (err) {
        console.error("[UI] Error while showing confirm dialog:", err);
        // Fallback to window.confirm if Tauri dialog fails
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      console.log("[UI] Confirm result:", confirmed);
      if (!confirmed) {
        console.log("[UI] User cancelled clean confirmation dialog");
        return;
      }

      // Calculate total items to clean (each item individually)
      const totalItems = selectedBc.length + selectedIdb.length + selectedLc.length;
      let currentItem = 0;

      // Show progress bar
      showProgress();
      hideStatus();
      console.log("[UI] Starting clean operation... Total items:", totalItems);
      
      try {
        let totalFreed = 0;
        
        // Clean basic caches - one by one
        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateProgress(percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${selectedBc.length}...`);
          
          console.log("[UI] Invoking clean_cache for:", cache.cache_type);
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          console.log("[UI] clean_cache result:", result);
          totalFreed += result.freed_bytes || 0;
        }
        
        // Clean IndexedDB - one by one
        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning IndexedDB ${i + 1}/${selectedIdb.length} (${idbItem.origin})...`);
          
          console.log("[UI] Invoking clean_indexed_db_items for origin:", idbItem.origin);
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          console.log("[UI] clean_indexed_db_items result:", idbResult);
          totalFreed += idbResult.total_freed_bytes || 0;
        }

        // Clean large caches - one by one
        for (let i = 0; i < selectedLc.length; i++) {
          const cache = selectedLc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning cache ${i + 1}/${selectedLc.length} (${cache.name})...`);
          
          console.log("[UI] Invoking remove_large_caches for:", cache.path);
          const lcResult = await invoke('remove_large_caches', {
            paths: [cache.path]
          });
          console.log("[UI] remove_large_caches result:", lcResult);
          totalFreed += lcResult.total_freed_bytes || 0;
        }
        
        // Only set 100% after ALL items are actually deleted
        updateProgress(100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to show 100%
        hideProgress();
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        console.log("[UI] Clean operation finished. Total freed bytes:", totalFreed);
        await scanData();
      } catch(e) {
        console.error("[UI] Error during cleanSelected:", e);
        hideProgress();
        showStatus('Error: ' + e);
      }
    }

    // Initialize
    if (window.__TAURI__) {
      console.log("[UI] Tauri detected, initializing immediately");
      invoke = window.__TAURI__.core.invoke;
      document.getElementById('btnScan').addEventListener('click', scanData);
      document.getElementById('btnPreview').addEventListener('click', previewClean);
      document.getElementById('btnClean').addEventListener('click', cleanSelected);
      document.getElementById('btnCleanBasic').addEventListener('click', cleanBasicCaches);
      document.getElementById('btnCleanLarge').addEventListener('click', cleanLargeCaches);
      document.getElementById('btnCleanIndexedDb').addEventListener('click', cleanIndexedDbItems);
      document.getElementById('btnCleanBrowserCaches').addEventListener('click', cleanBrowserCaches);
      document.getElementById('btnCleanPackageManagers').addEventListener('click', cleanPackageManagers);
      document.getElementById('btnCleanDevTools').addEventListener('click', cleanDevTools);
      document.getElementById('btnCleanSystemCaches').addEventListener('click', cleanSystemCaches);
      scanData();
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (window.__TAURI__) {
            console.log("[UI] Tauri became available after DOMContentLoaded");
            invoke = window.__TAURI__.core.invoke;
            document.getElementById('btnScan').addEventListener('click', scanData);
            document.getElementById('btnPreview').addEventListener('click', previewClean);
            document.getElementById('btnClean').addEventListener('click', cleanSelected);
            document.getElementById('btnCleanBasic').addEventListener('click', cleanBasicCaches);
            document.getElementById('btnCleanLarge').addEventListener('click', cleanLargeCaches);
            document.getElementById('btnCleanIndexedDb').addEventListener('click', cleanIndexedDbItems);
            document.getElementById('btnCleanBrowserCaches').addEventListener('click', cleanBrowserCaches);
            document.getElementById('btnCleanPackageManagers').addEventListener('click', cleanPackageManagers);
            document.getElementById('btnCleanDevTools').addEventListener('click', cleanDevTools);
            document.getElementById('btnCleanSystemCaches').addEventListener('click', cleanSystemCaches);
            scanData();
          } else {
            showStatus('Tauri API not available');
          }
        }, 100);
      });
    }
  </script>
</body>
</html>
