<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Cleaner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 20px; font-weight: 300; }
    h2 { font-size: 16px; margin: 20px 0 10px; color: #888; }
    .cache-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .cache-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cache-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .cache-info { flex: 1; }
    .cache-name { font-weight: 500; font-size: 15px; }
    .cache-path { font-size: 11px; color: #888; margin-top: 3px; word-break: break-all; }
    .cache-size { font-size: 14px; color: #4ade80; font-weight: 500; }
    .cache-size.large { color: #f87171; }
    .actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-scan { background: #3b82f6; color: #fff; }
    .btn-preview { background: #8b5cf6; color: #fff; }
    .btn-clean { background: #ef4444; color: #fff; }
    .status { text-align: center; margin-top: 15px; padding: 12px; border-radius: 8px; background: rgba(255,255,255,0.05); white-space: pre-line; }
    .alert { background: rgba(239, 68, 68, 0.2); color: #f87171; padding: 12px; border-radius: 8px; margin-bottom: 15px; }
    .alert-title { font-weight: 600; margin-bottom: 8px; }
    .total { text-align: center; font-size: 22px; margin: 15px 0; color: #4ade80; }
    .ext-item { background: rgba(239, 68, 68, 0.1); border-left: 3px solid #f87171; }
    .section { margin-bottom: 20px; }
    .progress-container { margin-top: 15px; display: none; }
    .progress-bar-wrapper {
      width: 100%;
      height: 24px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      border-radius: 12px;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 11px;
      font-weight: 500;
    }
    .progress-text {
      text-align: center;
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }
    .section-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .section-progress-container {
      margin-top: 10px;
      display: none;
    }
    /* Tab Navigation */
    .tab-nav {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 4px;
    }
    .tab-btn {
      flex: 1;
      padding: 12px 20px;
      background: transparent;
      color: #888;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .tab-btn.active {
      background: #3b82f6;
      color: #fff;
    }
    .tab-btn:hover:not(.active) {
      background: rgba(255,255,255,0.1);
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    /* Smart Scanner Styles */
    .score-badge {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    .score-high { background: #ef4444; color: #fff; }
    .score-medium { background: #f59e0b; color: #fff; }
    .score-low { background: #22c55e; color: #fff; }
    .reasons-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .reason-tag {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
    }
    .last-accessed {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }
    .filter-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      align-items: center;
      justify-content: center;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .filter-group label {
      font-size: 12px;
      color: #888;
    }
    .filter-group input {
      width: 70px;
      padding: 6px 8px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-size: 12px;
    }
    /* Multi-path display */
    .cache-paths {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 4px;
    }
    .path-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #888;
      padding: 4px 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      word-break: break-all;
    }
    .path-item:hover {
      background: rgba(255,255,255,0.1);
    }
    .path-icon {
      flex-shrink: 0;
      opacity: 0.6;
    }
    .path-text {
      flex: 1;
      min-width: 0;
    }
    .path-copy-btn {
      flex-shrink: 0;
      padding: 2px 6px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 3px;
      color: #888;
      font-size: 10px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .path-item:hover .path-copy-btn {
      opacity: 1;
    }
    .path-copy-btn:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }
    /* Chrome with nested IndexedDB styles */
    .browser-item-container {
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    .browser-main-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .browser-main-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .indexeddb-subsection {
      margin: 0;
      padding: 12px 14px;
      background: rgba(0,0,0,0.15);
      border-top: 1px solid rgba(255,255,255,0.08);
    }
    .indexeddb-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 8px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    .indexeddb-header:hover {
      background: rgba(255,255,255,0.1);
    }
    .indexeddb-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .indexeddb-toggle {
      font-size: 12px;
      transition: transform 0.3s;
      color: #888;
    }
    .indexeddb-toggle.collapsed {
      transform: rotate(-90deg);
    }
    .indexeddb-title {
      font-size: 13px;
      color: #a0aec0;
      font-weight: 500;
    }
    .indexeddb-badge {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 500;
    }
    .indexeddb-description {
      font-size: 11px;
      color: #666;
      padding: 0 12px 10px;
      line-height: 1.4;
    }
    .indexeddb-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 400px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .indexeddb-items.collapsed {
      display: none;
    }
    .indexeddb-item {
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: 8px;
      border-left: 2px solid rgba(59, 130, 246, 0.3);
    }
    .indexeddb-item.large-item {
      border-left-color: #f87171;
      background: rgba(239, 68, 68, 0.08);
    }
    .indexeddb-item input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
    .indexeddb-item .cache-info { flex: 1; }
    .indexeddb-item .cache-name { font-size: 13px; font-weight: 500; }
    .indexeddb-item .cache-path { font-size: 10px; color: #666; margin-top: 2px; }
    .indexeddb-item .cache-size { font-size: 13px; }
    .indexeddb-total {
      font-size: 12px;
      color: #888;
      margin-left: auto;
    }
    .chrome-total-size {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }
    .chrome-cache-size {
      font-size: 14px;
      color: #4ade80;
      font-weight: 500;
    }
    .chrome-indexeddb-size {
      font-size: 11px;
      color: #93c5fd;
    }
    /* Select all checkbox for IndexedDB */
    .indexeddb-select-all {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      margin-bottom: 8px;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 6px;
      font-size: 12px;
      color: #93c5fd;
    }
    .indexeddb-select-all input[type="checkbox"] {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }
    /* Docker Cleanup Styles */
    .docker-status-card {
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }
    .docker-status-header {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 12px;
    }
    .docker-status-indicator {
      font-size: 14px;
      transition: color 0.3s;
    }
    .docker-status-indicator.running { color: #4ade80; }
    .docker-status-indicator.stopped { color: #f87171; }
    .docker-status-indicator.checking { color: #fbbf24; animation: pulse 1s infinite; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .docker-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .docker-summary-item {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .docker-total-size {
      font-size: 20px;
      font-weight: 600;
      color: #4ade80;
    }
    .docker-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    .docker-stat-item {
      background: rgba(255,255,255,0.06);
      border-radius: 10px;
      padding: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .docker-stat-icon {
      font-size: 20px;
    }
    .docker-stat-label {
      flex: 1;
      font-size: 12px;
      color: #888;
    }
    .docker-stat-value {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
    }
    .docker-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 8px 0;
      margin-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .docker-section-header h2 {
      font-size: 15px;
      color: #a0aec0;
      margin: 0;
    }
    .docker-section-toggle {
      font-size: 12px;
      color: #888;
      transition: transform 0.3s;
    }
    .docker-section-toggle.collapsed {
      transform: rotate(-90deg);
    }
    .docker-section-content.collapsed {
      display: none;
    }
    .docker-item {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 8px;
    }
    .docker-item.auto-select {
      background: rgba(239, 68, 68, 0.15);
      border-left: 3px solid #f87171;
    }
    .docker-item.dangling {
      background: rgba(251, 191, 36, 0.15);
      border-left: 3px solid #fbbf24;
    }
    .docker-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      margin-top: 2px;
    }
    .docker-item-info {
      flex: 1;
      min-width: 0;
    }
    .docker-item-name {
      font-weight: 500;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .docker-item-id {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
      font-family: monospace;
    }
    .docker-item-meta {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
    }
    .docker-item-size {
      font-size: 14px;
      color: #4ade80;
      font-weight: 500;
      white-space: nowrap;
    }
    .docker-item-size.large {
      color: #f87171;
    }
    .docker-badge {
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .docker-badge.dangling {
      background: rgba(251, 191, 36, 0.3);
      color: #fbbf24;
    }
    .docker-badge.unused {
      background: rgba(239, 68, 68, 0.3);
      color: #f87171;
    }
    .docker-badge.orphan {
      background: rgba(139, 92, 246, 0.3);
      color: #a78bfa;
    }
    .docker-badge.exited {
      background: rgba(107, 114, 128, 0.3);
      color: #9ca3af;
    }
    .docker-badge.dead {
      background: rgba(239, 68, 68, 0.3);
      color: #f87171;
    }
    .docker-score-badge {
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      margin-left: auto;
    }
    .docker-score-badge.high { background: #ef4444; color: #fff; }
    .docker-score-badge.medium { background: #f59e0b; color: #fff; }
    .docker-score-badge.low { background: #22c55e; color: #fff; }
    .docker-reasons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .docker-reason-tag {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
    }
    .docker-empty-state {
      text-align: center;
      padding: 30px;
      color: #666;
      font-size: 14px;
    }
    .docker-not-running {
      text-align: center;
      padding: 40px 20px;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 12px;
      margin: 20px 0;
    }
    .docker-not-running-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    .docker-not-running-title {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 8px;
    }
    .docker-not-running-text {
      color: #888;
      font-size: 14px;
    }
    .docker-build-cache-item {
      background: rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .docker-build-cache-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .docker-build-cache-icon {
      font-size: 24px;
    }
    .docker-build-cache-label {
      font-size: 14px;
      font-weight: 500;
    }
    .docker-build-cache-size {
      font-size: 18px;
      font-weight: 600;
      color: #4ade80;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßπ Cache Cleaner</h1>
    
    <!-- Tab Navigation -->
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="cache-cleaner">üóÇ Cache Cleaner</button>
      <button class="tab-btn" data-tab="smart-scanner">üîç Smart Scanner</button>
      <button class="tab-btn" data-tab="docker-cleanup">üê≥ Docker</button>
    </div>

    <!-- Cache Cleaner Tab -->
    <div id="cache-cleaner-tab" class="tab-content active">
    <div class="total">Total: <span id="totalSize">0 MB</span></div>

    <div id="basicCachesSection" class="section" style="display:none;">
      <h2>üóÇ Editor cache</h2>
      <div id="basicCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBasic">üóë Clear Editor cache</button>
      </div>
      <div id="basicCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="basicCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="basicCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="browserCachesSection" class="section" style="display:none;">
      <h2>üåê Browser Caches</h2>
      <div id="browserCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanBrowserCaches">üóë Clear Browser Caches</button>
      </div>
      <div id="browserCachesProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="browserCachesProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="browserCachesProgressText" class="progress-text"></div>
      </div>
    </div>

    <div id="packageManagersSection" class="section" style="display:none;">
      <h2>üì¶ Package Managers</h2>
      <div id="packageManagersList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanPackageManagers">üóë Clear Package Managers</button>
      </div>
    </div>

    <div id="devToolsSection" class="section" style="display:none;">
      <h2>üîß Development Tools</h2>
      <div id="devToolsList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanDevTools">üóë Clear Dev Tools</button>
      </div>
    </div>

    <div id="systemCachesSection" class="section" style="display:none;">
      <h2>üñ• System Caches</h2>
      <div id="systemCachesList" class="cache-list"></div>
      <div class="section-actions">
        <button class="btn-clean" id="btnCleanSystemCaches">üóë Clear System Caches</button>
      </div>
    </div>

    <div class="actions">
      <button class="btn-scan" id="btnScan">üîç Scan</button>
      <button class="btn-preview" id="btnPreview">üëÅ Preview</button>
      <button class="btn-clean" id="btnClean">üóë Clean Selected</button>
    </div>

    <div id="status" class="status" style="display:none;"></div>
    <div id="progressContainer" class="progress-container">
      <div class="progress-bar-wrapper">
        <div id="progressBar" class="progress-bar" style="width: 0%;">0%</div>
      </div>
      <div id="progressText" class="progress-text"></div>
    </div>
    </div><!-- End Cache Cleaner Tab -->

    <!-- Smart Scanner Tab -->
    <div id="smart-scanner-tab" class="tab-content">
      <div class="total">Smart Suggestions: <span id="smartScannerTotal">0 MB</span></div>
      
      <div class="filter-controls">
        <div class="filter-group">
          <label>Min Size (MB):</label>
          <input type="number" id="minSizeMb" value="100" min="0">
        </div>
        <div class="filter-group">
          <label>Max Age (days):</label>
          <input type="number" id="maxAgeDays" value="30" min="0">
        </div>
      </div>

      <div class="actions">
        <button class="btn-scan" id="btnSmartScan">üîç Scan Suggestions</button>
      </div>

      <div id="smartScannerSection" class="section" style="display:none;">
        <h2>üìÅ Suggested Folders to Clean</h2>
        <div id="smartScannerList" class="cache-list"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanSmartScanner">üóë Delete Selected</button>
        </div>
        <div id="smartScannerProgress" class="section-progress-container">
          <div class="progress-bar-wrapper">
            <div id="smartScannerProgressBar" class="progress-bar" style="width: 0%;">0%</div>
          </div>
          <div id="smartScannerProgressText" class="progress-text"></div>
        </div>
      </div>

      <div id="smartScannerStatus" class="status" style="display:none;"></div>
    </div><!-- End Smart Scanner Tab -->

    <!-- Docker Cleanup Tab -->
    <div id="docker-cleanup-tab" class="tab-content">
      <!-- Docker Status Card -->
      <div class="docker-status-card">
        <div class="docker-status-header">
          <span class="docker-status-indicator" id="dockerStatusIndicator">‚óè</span>
          <span id="dockerStatusText">Checking Docker...</span>
        </div>
        <div class="docker-summary" id="dockerSummary">
          <div class="docker-summary-item">
            <span>Total Reclaimable:</span>
            <span class="docker-total-size" id="dockerTotalSize">0 MB</span>
          </div>
        </div>
      </div>

      <!-- Docker Stats Overview -->
      <div class="docker-stats" id="dockerStats" style="display:none;">
        <div class="docker-stat-item">
          <span class="docker-stat-icon">üì¶</span>
          <span class="docker-stat-label">Stopped Containers</span>
          <span class="docker-stat-value" id="dockerStoppedCount">0</span>
        </div>
        <div class="docker-stat-item">
          <span class="docker-stat-icon">üñºÔ∏è</span>
          <span class="docker-stat-label">Unused Images</span>
          <span class="docker-stat-value" id="dockerUnusedImagesCount">0</span>
        </div>
        <div class="docker-stat-item">
          <span class="docker-stat-icon">üíæ</span>
          <span class="docker-stat-label">Orphan Volumes</span>
          <span class="docker-stat-value" id="dockerOrphanVolumesCount">0</span>
        </div>
        <div class="docker-stat-item">
          <span class="docker-stat-icon">üåê</span>
          <span class="docker-stat-label">Unused Networks</span>
          <span class="docker-stat-value" id="dockerUnusedNetworksCount">0</span>
        </div>
      </div>

      <!-- Scan Button -->
      <div class="actions">
        <button class="btn-scan" id="btnDockerScan">üîç Scan Docker</button>
        <button class="btn-preview" id="btnDockerPruneAll" style="display:none;">üßπ Prune All</button>
      </div>

      <!-- Docker Containers Section -->
      <div id="dockerContainersSection" class="section" style="display:none;">
        <div class="docker-section-header" onclick="toggleDockerSection('containers')">
          <h2>üì¶ Stopped Containers</h2>
          <span class="docker-section-toggle" id="containersToggle">‚ñº</span>
        </div>
        <div id="dockerContainersList" class="cache-list docker-section-content"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanDockerContainers">üóë Remove Selected Containers</button>
        </div>
      </div>

      <!-- Docker Images Section -->
      <div id="dockerImagesSection" class="section" style="display:none;">
        <div class="docker-section-header" onclick="toggleDockerSection('images')">
          <h2>üñºÔ∏è Docker Images</h2>
          <span class="docker-section-toggle" id="imagesToggle">‚ñº</span>
        </div>
        <div id="dockerImagesList" class="cache-list docker-section-content"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanDockerImages">üóë Remove Selected Images</button>
        </div>
      </div>

      <!-- Docker Volumes Section -->
      <div id="dockerVolumesSection" class="section" style="display:none;">
        <div class="docker-section-header" onclick="toggleDockerSection('volumes')">
          <h2>üíæ Orphan Volumes</h2>
          <span class="docker-section-toggle" id="volumesToggle">‚ñº</span>
        </div>
        <div id="dockerVolumesList" class="cache-list docker-section-content"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanDockerVolumes">üóë Remove Selected Volumes</button>
        </div>
      </div>

      <!-- Docker Networks Section -->
      <div id="dockerNetworksSection" class="section" style="display:none;">
        <div class="docker-section-header" onclick="toggleDockerSection('networks')">
          <h2>üåê Unused Networks</h2>
          <span class="docker-section-toggle" id="networksToggle">‚ñº</span>
        </div>
        <div id="dockerNetworksList" class="cache-list docker-section-content"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanDockerNetworks">üóë Remove Selected Networks</button>
        </div>
      </div>

      <!-- Docker Build Cache Section -->
      <div id="dockerBuildCacheSection" class="section" style="display:none;">
        <div class="docker-section-header">
          <h2>üî® Build Cache</h2>
        </div>
        <div id="dockerBuildCacheInfo" class="cache-list"></div>
        <div class="section-actions">
          <button class="btn-clean" id="btnCleanDockerBuildCache">üóë Clear Build Cache</button>
        </div>
      </div>

      <!-- Docker Progress -->
      <div id="dockerProgress" class="section-progress-container" style="display:none;">
        <div class="progress-bar-wrapper">
          <div id="dockerProgressBar" class="progress-bar" style="width: 0%;">0%</div>
        </div>
        <div id="dockerProgressText" class="progress-text"></div>
      </div>

      <div id="dockerStatus" class="status" style="display:none;"></div>
    </div><!-- End Docker Cleanup Tab -->
  </div>

  <script>
    let basicCaches = [];
    let indexedDbItems = [];
    let npmCaches = [];
    let browserCaches = [];
    let packageManagers = [];
    let devTools = [];
    let systemCaches = [];
    let smartSuggestions = [];
    const INDEXED_DB_THRESHOLD_MB = 10;
    let invoke;

    // Docker state variables
    let dockerScanResult = null;
    let dockerContainers = [];
    let dockerImages = [];
    let dockerVolumes = [];
    let dockerNetworks = [];
    let dockerSuggestions = [];
    let dockerBuildCacheSize = 0;
    let dockerDaemonRunning = false;

    function getCacheTypeName(type) {
      const names = {
        'npm': 'NPM',
        'chrome': 'Chrome',
        'cachedir': '.cache Directory',
        'cache_dir': '.cache Directory',
        'vscode': 'VSCode',
        'code': 'VSCode',
        'cursor': 'Cursor',
        'safari': 'Safari',
        'firefox': 'Firefox',
        'arc': 'Arc',
        'yarn': 'Yarn',
        'pnpm': 'PNPM',
        'pip': 'Pip',
        'cocoapods': 'CocoaPods',
        'gradle': 'Gradle',
        'cargo': 'Cargo',
        'xcodederiveddata': 'Xcode Derived Data',
        'xcodearchives': 'Xcode Archives',
        'xcodesimulators': 'Xcode Simulators',
        'systemcaches': 'System Caches',
        'userlogs': 'User Logs',
        'tempfiles': 'Temp Files',
        'iosbackups': 'iOS Backups'
      };
      const typeStr = getCacheTypeString(type);
      return names[typeStr.toLowerCase()] || typeStr;
    }

    function getCacheTypeString(type) {
      if (typeof type === 'string') return type;
      return JSON.stringify(type).replace(/"/g, '');
    }

    function formatSize(bytes) {
      if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
      if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes + ' bytes';
    }

    function renderPaths(pathString) {
      const paths = pathString.split('\n').filter(p => p.trim());
      if (paths.length <= 1) {
        return `<div class="cache-path">${pathString}</div>`;
      }
      
      return `<div class="cache-paths">
        ${paths.map(p => `
          <div class="path-item">
            <span class="path-icon">üìÅ</span>
            <span class="path-text">${p}</span>
            <button class="path-copy-btn" onclick="copyPath('${p.replace(/'/g, "\\'")}', event)">Copy</button>
          </div>
        `).join('')}
      </div>`;
    }

    function copyPath(path, event) {
      navigator.clipboard.writeText(path).then(() => {
        const btn = event.target;
        btn.textContent = '‚úì';
        btn.style.color = '#4ade80';
        setTimeout(() => { 
          btn.textContent = 'Copy'; 
          btn.style.color = '';
        }, 1000);
      });
    }

    function showStatus(msg) {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideStatus() {
      document.getElementById('status').style.display = 'none';
    }

    function showProgress() {
      document.getElementById('progressContainer').style.display = 'block';
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressBar').textContent = '0%';
      document.getElementById('progressText').textContent = '';
    }

    function updateProgress(percentage, message) {
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const clampedPercentage = Math.min(100, Math.max(0, percentage));
      progressBar.style.width = clampedPercentage + '%';
      progressBar.textContent = Math.round(clampedPercentage) + '%';
      if (message) {
        progressText.textContent = message;
      }
    }

    function hideProgress() {
      document.getElementById('progressContainer').style.display = 'none';
    }

    // Tab Navigation
    function switchTab(tabId) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      document.getElementById(`${tabId}-tab`).classList.add('active');
    }

    // Smart Scanner Functions
    function showSmartScannerStatus(msg) {
      const el = document.getElementById('smartScannerStatus');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideSmartScannerStatus() {
      document.getElementById('smartScannerStatus').style.display = 'none';
    }

    function getScoreBadgeClass(score) {
      if (score >= 0.7) return 'score-high';
      if (score >= 0.4) return 'score-medium';
      return 'score-low';
    }

    function renderSmartScannerFolders() {
      const section = document.getElementById('smartScannerSection');
      const list = document.getElementById('smartScannerList');

      section.style.display = 'block';

      if (!smartSuggestions.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No suggestions found</div></div></div>';
        document.getElementById('btnCleanSmartScanner').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanSmartScanner').style.display = 'block';

      list.innerHTML = smartSuggestions.map((item, i) => `
        <div class="cache-item ${item.score >= 0.7 ? 'ext-item' : ''}">
          <input type="checkbox" id="ss${i}" data-index="${i}" class="ss-checkbox" ${item.score >= 0.5 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">
              ${item.name}
              <span class="score-badge ${getScoreBadgeClass(item.score)}">${Math.round(item.score * 100)}%</span>
            </div>
            ${renderPaths(item.path)}
            <div class="reasons-tags">
              ${item.reasons.map(r => `<span class="reason-tag">${r}</span>`).join('')}
            </div>
            ${item.last_accessed_days_ago ? `<div class="last-accessed">Last accessed: ${item.last_accessed_days_ago} days ago</div>` : ''}
          </div>
          <div class="cache-size ${item.size_bytes > 1073741824 ? 'large' : ''}">${formatSize(item.size_bytes)}</div>
        </div>
      `).join('');

      updateSmartScannerTotal();
    }

    function updateSmartScannerTotal() {
      const total = smartSuggestions.reduce((sum, s) => sum + s.size_bytes, 0);
      document.getElementById('smartScannerTotal').textContent = formatSize(total);
    }

    function getSelectedSmartSuggestions() {
      return [...document.querySelectorAll('.ss-checkbox:checked')]
        .map(cb => smartSuggestions[parseInt(cb.dataset.index)]);
    }

    async function scanSmartSuggestions() {
      showSmartScannerStatus('Scanning...');
      try {
        const minSizeMb = parseInt(document.getElementById('minSizeMb').value) || 100;
        const maxAgeDays = parseInt(document.getElementById('maxAgeDays').value) || 30;
        
        smartSuggestions = await invoke('scan_smart_suggestions', { minSizeMb, maxAgeDays });
        renderSmartScannerFolders();
        hideSmartScannerStatus();
      } catch (e) {
        showSmartScannerStatus('Error: ' + e);
      }
    }

    async function deleteSmartScannerFolders() {
      const selected = getSelectedSmartSuggestions();
      
      if (!selected.length) {
        showSmartScannerStatus('Select at least one folder');
        return;
      }

      const totalSize = selected.reduce((sum, s) => sum + s.size_bytes, 0);
      let msg = `Are you sure you want to delete ${selected.length} folder(s)?`;
      msg += `\n\n‚ö†Ô∏è WARNING: This will permanently delete ${formatSize(totalSize)} of data.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Deletion',
            kind: 'warning',
            okLabel: 'Yes, Delete',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      const progressContainer = document.getElementById('smartScannerProgress');
      const progressBar = document.getElementById('smartScannerProgressBar');
      const progressText = document.getElementById('smartScannerProgressText');
      progressContainer.style.display = 'block';
      hideSmartScannerStatus();

      try {
        let totalFreed = 0;
        const totalItems = selected.length;

        for (let i = 0; i < selected.length; i++) {
          const item = selected[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          progressBar.style.width = percentage + '%';
          progressBar.textContent = Math.round(percentage) + '%';
          progressText.textContent = `Deleting ${i + 1}/${totalItems} (${item.name})...`;

          const result = await invoke('remove_smart_suggestions', { paths: [item.path] });
          totalFreed += result.total_freed_bytes || 0;
        }

        progressBar.style.width = '100%';
        progressBar.textContent = '100%';
        progressText.textContent = 'Completed!';
        await new Promise(resolve => setTimeout(resolve, 500));
        progressContainer.style.display = 'none';
        showSmartScannerStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanSmartSuggestions();
      } catch (e) {
        progressContainer.style.display = 'none';
        showSmartScannerStatus('Error: ' + e);
      }
    }

    // ==================== Docker Functions ====================

    function showDockerStatus(msg) {
      const el = document.getElementById('dockerStatus');
      el.style.display = 'block';
      el.textContent = msg;
    }

    function hideDockerStatus() {
      document.getElementById('dockerStatus').style.display = 'none';
    }

    function updateDockerStatusIndicator(running) {
      const indicator = document.getElementById('dockerStatusIndicator');
      const text = document.getElementById('dockerStatusText');
      
      indicator.classList.remove('running', 'stopped', 'checking');
      
      if (running) {
        indicator.classList.add('running');
        text.textContent = 'Docker is running';
      } else {
        indicator.classList.add('stopped');
        text.textContent = 'Docker is not running';
      }
    }

    function setDockerChecking() {
      const indicator = document.getElementById('dockerStatusIndicator');
      const text = document.getElementById('dockerStatusText');
      indicator.classList.remove('running', 'stopped');
      indicator.classList.add('checking');
      text.textContent = 'Checking Docker...';
    }

    function toggleDockerSection(sectionName) {
      const toggle = document.getElementById(sectionName + 'Toggle');
      const content = document.querySelector(`#docker${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)}sList`);
      if (toggle && content) {
        toggle.classList.toggle('collapsed');
        content.classList.toggle('collapsed');
      }
    }

    function getDockerScoreBadgeClass(score) {
      if (score >= 0.7) return 'high';
      if (score >= 0.4) return 'medium';
      return 'low';
    }

    function getContainerStateBadge(state) {
      const stateStr = typeof state === 'string' ? state.toLowerCase() : 'unknown';
      const badges = {
        'exited': '<span class="docker-badge exited">Exited</span>',
        'dead': '<span class="docker-badge dead">Dead</span>',
        'created': '<span class="docker-badge exited">Created</span>',
        'paused': '<span class="docker-badge exited">Paused</span>',
      };
      return badges[stateStr] || '';
    }

    async function scanDocker() {
      setDockerChecking();
      showDockerStatus('Scanning Docker resources...');
      
      try {
        // First check if Docker is running
        dockerDaemonRunning = await invoke('check_docker_status');
        updateDockerStatusIndicator(dockerDaemonRunning);
        
        if (!dockerDaemonRunning) {
          showDockerNotRunning();
          hideDockerStatus();
          return;
        }

        // Scan Docker resources
        dockerScanResult = await invoke('scan_docker');
        
        if (!dockerScanResult.daemon_running) {
          dockerDaemonRunning = false;
          updateDockerStatusIndicator(false);
          showDockerNotRunning();
          hideDockerStatus();
          return;
        }

        dockerContainers = dockerScanResult.containers || [];
        dockerImages = dockerScanResult.images || [];
        dockerVolumes = dockerScanResult.volumes || [];
        dockerNetworks = dockerScanResult.networks || [];
        dockerBuildCacheSize = dockerScanResult.build_cache_size || 0;

        // Get smart suggestions
        try {
          dockerSuggestions = await invoke('get_docker_suggestions');
        } catch (e) {
          console.warn('Could not get Docker suggestions:', e);
          dockerSuggestions = [];
        }

        // Update stats
        updateDockerStats();
        
        // Render sections
        renderDockerContainers();
        renderDockerImages();
        renderDockerVolumes();
        renderDockerNetworks();
        renderDockerBuildCache();
        
        // Update total
        updateDockerTotal();
        
        // Show prune button
        document.getElementById('btnDockerPruneAll').style.display = 'inline-block';
        document.getElementById('dockerStats').style.display = 'grid';
        
        hideDockerStatus();
      } catch (e) {
        console.error('Docker scan error:', e);
        showDockerStatus('Error: ' + e);
        updateDockerStatusIndicator(false);
      }
    }

    function showDockerNotRunning() {
      // Hide all sections
      document.getElementById('dockerContainersSection').style.display = 'none';
      document.getElementById('dockerImagesSection').style.display = 'none';
      document.getElementById('dockerVolumesSection').style.display = 'none';
      document.getElementById('dockerNetworksSection').style.display = 'none';
      document.getElementById('dockerBuildCacheSection').style.display = 'none';
      document.getElementById('dockerStats').style.display = 'none';
      document.getElementById('btnDockerPruneAll').style.display = 'none';
      
      // Show not running message
      showDockerStatus(`
        üê≥ Docker Desktop is not running
        
        Please start Docker Desktop to scan and clean Docker resources.
      `);
    }

    function updateDockerStats() {
      if (!dockerScanResult) return;
      
      document.getElementById('dockerStoppedCount').textContent = dockerScanResult.stopped_containers_count || 0;
      document.getElementById('dockerUnusedImagesCount').textContent = dockerScanResult.unused_images_count || 0;
      document.getElementById('dockerOrphanVolumesCount').textContent = dockerScanResult.orphan_volumes_count || 0;
      document.getElementById('dockerUnusedNetworksCount').textContent = dockerScanResult.unused_networks_count || 0;
    }

    function updateDockerTotal() {
      if (!dockerScanResult) {
        document.getElementById('dockerTotalSize').textContent = '0 MB';
        return;
      }
      document.getElementById('dockerTotalSize').textContent = formatSize(dockerScanResult.total_reclaimable || 0);
    }

    function getSuggestionForResource(resourceType, id) {
      return dockerSuggestions.find(s => 
        s.resource_type === resourceType && s.id === id
      );
    }

    function renderDockerContainers() {
      const section = document.getElementById('dockerContainersSection');
      const list = document.getElementById('dockerContainersList');

      // Filter stopped containers
      const stoppedContainers = dockerContainers.filter(c => {
        const state = typeof c.state === 'string' ? c.state.toLowerCase() : '';
        return state !== 'running';
      });

      if (!stoppedContainers.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      list.innerHTML = stoppedContainers.map((container, i) => {
        const suggestion = getSuggestionForResource('Container', container.id);
        const score = suggestion ? suggestion.score : 0;
        const reasons = suggestion ? suggestion.reasons : [];
        const autoSelect = suggestion ? suggestion.auto_select : false;
        const stateStr = typeof container.state === 'string' ? container.state : 'Unknown';
        const isTop5 = i < 5;

        return `
          <div class="docker-item ${autoSelect ? 'auto-select' : ''}">
            <input type="checkbox" id="dc${i}" data-id="${container.id}" class="docker-container-checkbox" ${isTop5 ? 'checked' : ''}>
            <div class="docker-item-info">
              <div class="docker-item-name">
                ${container.name}
                ${getContainerStateBadge(stateStr)}
                ${score > 0 ? `<span class="docker-score-badge ${getDockerScoreBadgeClass(score)}">${Math.round(score * 100)}%</span>` : ''}
              </div>
              <div class="docker-item-id">ID: ${container.id.substring(0, 12)}</div>
              <div class="docker-item-meta">Image: ${container.image} | ${container.status}</div>
              ${reasons.length ? `<div class="docker-reasons">${reasons.map(r => `<span class="docker-reason-tag">${r}</span>`).join('')}</div>` : ''}
            </div>
            <div class="docker-item-size ${container.size > 100 * 1024 * 1024 ? 'large' : ''}">${formatSize(container.size)}</div>
          </div>
        `;
      }).join('');
    }

    function renderDockerImages() {
      const section = document.getElementById('dockerImagesSection');
      const list = document.getElementById('dockerImagesList');

      // Filter unused images
      const unusedImages = dockerImages.filter(img => 
        img.is_dangling || img.used_by_containers.length === 0
      );

      if (!unusedImages.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      // Sort: dangling first, then by size
      unusedImages.sort((a, b) => {
        if (a.is_dangling && !b.is_dangling) return -1;
        if (!a.is_dangling && b.is_dangling) return 1;
        return b.size - a.size;
      });

      list.innerHTML = unusedImages.map((image, i) => {
        const suggestion = getSuggestionForResource('Image', image.id);
        const score = suggestion ? suggestion.score : 0;
        const reasons = suggestion ? suggestion.reasons : [];
        const autoSelect = suggestion ? suggestion.auto_select : image.is_dangling;
        const isTop5 = i < 5;
        
        const displayName = image.repository === '<none>' 
          ? `<none>:<none>` 
          : `${image.repository}:${image.tag}`;

        return `
          <div class="docker-item ${image.is_dangling ? 'dangling' : ''} ${autoSelect ? 'auto-select' : ''}">
            <input type="checkbox" id="di${i}" data-id="${image.id}" class="docker-image-checkbox" ${isTop5 ? 'checked' : ''}>
            <div class="docker-item-info">
              <div class="docker-item-name">
                ${displayName}
                ${image.is_dangling ? '<span class="docker-badge dangling">Dangling</span>' : '<span class="docker-badge unused">Unused</span>'}
                ${score > 0 ? `<span class="docker-score-badge ${getDockerScoreBadgeClass(score)}">${Math.round(score * 100)}%</span>` : ''}
              </div>
              <div class="docker-item-id">ID: ${image.id.substring(0, 19)}</div>
              <div class="docker-item-meta">Created: ${image.created}</div>
              ${reasons.length ? `<div class="docker-reasons">${reasons.map(r => `<span class="docker-reason-tag">${r}</span>`).join('')}</div>` : ''}
            </div>
            <div class="docker-item-size ${image.size > 500 * 1024 * 1024 ? 'large' : ''}">${formatSize(image.size)}</div>
          </div>
        `;
      }).join('');
    }

    function renderDockerVolumes() {
      const section = document.getElementById('dockerVolumesSection');
      const list = document.getElementById('dockerVolumesList');

      // Filter orphan volumes
      const orphanVolumes = dockerVolumes.filter(v => v.used_by_containers.length === 0);

      if (!orphanVolumes.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      list.innerHTML = orphanVolumes.map((volume, i) => {
        const suggestion = getSuggestionForResource('Volume', volume.name);
        const score = suggestion ? suggestion.score : 1.0; // Orphan volumes always high score
        const reasons = suggestion ? suggestion.reasons : ['Orphan volume'];
        const isTop5 = i < 5;

        return `
          <div class="docker-item auto-select">
            <input type="checkbox" id="dv${i}" data-name="${volume.name}" class="docker-volume-checkbox" ${isTop5 ? 'checked' : ''}>
            <div class="docker-item-info">
              <div class="docker-item-name">
                ${volume.name.length > 40 ? volume.name.substring(0, 40) + '...' : volume.name}
                <span class="docker-badge orphan">Orphan</span>
                <span class="docker-score-badge ${getDockerScoreBadgeClass(score)}">${Math.round(score * 100)}%</span>
              </div>
              <div class="docker-item-id">Driver: ${volume.driver}</div>
              ${reasons.length ? `<div class="docker-reasons">${reasons.map(r => `<span class="docker-reason-tag">${r}</span>`).join('')}</div>` : ''}
            </div>
            <div class="docker-item-size">${volume.size ? formatSize(volume.size) : '-'}</div>
          </div>
        `;
      }).join('');
    }

    function renderDockerNetworks() {
      const section = document.getElementById('dockerNetworksSection');
      const list = document.getElementById('dockerNetworksList');

      // Filter unused networks (excluding defaults)
      const defaultNetworks = ['bridge', 'host', 'none'];
      const unusedNetworks = dockerNetworks.filter(n => 
        n.used_by_containers.length === 0 && !defaultNetworks.includes(n.name)
      );

      if (!unusedNetworks.length) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      list.innerHTML = unusedNetworks.map((network, i) => {
        const isTop5 = i < 5;
        return `
          <div class="docker-item">
            <input type="checkbox" id="dn${i}" data-id="${network.id}" class="docker-network-checkbox" ${isTop5 ? 'checked' : ''}>
            <div class="docker-item-info">
              <div class="docker-item-name">
                ${network.name}
                <span class="docker-badge unused">Unused</span>
              </div>
              <div class="docker-item-id">ID: ${network.id.substring(0, 12)}</div>
              <div class="docker-item-meta">Driver: ${network.driver} | Scope: ${network.scope}</div>
            </div>
            <div class="docker-item-size">-</div>
          </div>
        `;
      }).join('');
    }

    function renderDockerBuildCache() {
      const section = document.getElementById('dockerBuildCacheSection');
      const info = document.getElementById('dockerBuildCacheInfo');

      if (!dockerBuildCacheSize || dockerBuildCacheSize === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      info.innerHTML = `
        <div class="docker-build-cache-item">
          <div class="docker-build-cache-info">
            <span class="docker-build-cache-icon">üî®</span>
            <span class="docker-build-cache-label">Docker Build Cache</span>
          </div>
          <div class="docker-build-cache-size">${formatSize(dockerBuildCacheSize)}</div>
        </div>
      `;
    }

    // Docker Cleanup Functions
    function showDockerProgress() {
      const container = document.getElementById('dockerProgress');
      const bar = document.getElementById('dockerProgressBar');
      const text = document.getElementById('dockerProgressText');
      container.style.display = 'block';
      bar.style.width = '0%';
      bar.textContent = '0%';
      text.textContent = '';
    }

    function updateDockerProgress(percentage, message) {
      const bar = document.getElementById('dockerProgressBar');
      const text = document.getElementById('dockerProgressText');
      const clamped = Math.min(100, Math.max(0, percentage));
      bar.style.width = clamped + '%';
      bar.textContent = Math.round(clamped) + '%';
      if (message) text.textContent = message;
    }

    function hideDockerProgress() {
      document.getElementById('dockerProgress').style.display = 'none';
    }

    function getSelectedDockerContainers() {
      return [...document.querySelectorAll('.docker-container-checkbox:checked')]
        .map(cb => cb.dataset.id);
    }

    function getSelectedDockerImages() {
      return [...document.querySelectorAll('.docker-image-checkbox:checked')]
        .map(cb => cb.dataset.id);
    }

    function getSelectedDockerVolumes() {
      return [...document.querySelectorAll('.docker-volume-checkbox:checked')]
        .map(cb => cb.dataset.name);
    }

    function getSelectedDockerNetworks() {
      return [...document.querySelectorAll('.docker-network-checkbox:checked')]
        .map(cb => cb.dataset.id);
    }

    async function cleanDockerContainers() {
      const ids = getSelectedDockerContainers();
      
      if (!ids.length) {
        showDockerStatus('Select at least one container');
        return;
      }

      const containers = dockerContainers.filter(c => ids.includes(c.id));
      const totalSize = containers.reduce((sum, c) => sum + c.size, 0);
      
      let msg = `Are you sure you want to remove ${ids.length} container(s)?`;
      msg += `\n\nThis will free approximately ${formatSize(totalSize)}.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Remove Docker Containers',
            kind: 'warning',
            okLabel: 'Yes, Remove',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(50, 'Removing containers...');
        const result = await invoke('clean_docker_containers', { ids, force: true });
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        if (result.success) {
          showDockerStatus(`‚úÖ Removed ${result.containers_removed} container(s). Freed ${formatSize(result.freed_bytes)}`);
        } else {
          showDockerStatus(`‚ö†Ô∏è ${result.message}`);
        }
        
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    async function cleanDockerImages() {
      const ids = getSelectedDockerImages();
      
      if (!ids.length) {
        showDockerStatus('Select at least one image');
        return;
      }

      const images = dockerImages.filter(img => ids.includes(img.id));
      const totalSize = images.reduce((sum, img) => sum + img.size, 0);
      
      let msg = `Are you sure you want to remove ${ids.length} image(s)?`;
      msg += `\n\nThis will free approximately ${formatSize(totalSize)}.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Remove Docker Images',
            kind: 'warning',
            okLabel: 'Yes, Remove',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(50, 'Removing images...');
        const result = await invoke('clean_docker_images', { ids, force: true });
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        if (result.success) {
          showDockerStatus(`‚úÖ Removed ${result.images_removed} image(s). Freed ${formatSize(result.freed_bytes)}`);
        } else {
          showDockerStatus(`‚ö†Ô∏è ${result.message}`);
        }
        
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    async function cleanDockerVolumes() {
      const names = getSelectedDockerVolumes();
      
      if (!names.length) {
        showDockerStatus('Select at least one volume');
        return;
      }

      let msg = `Are you sure you want to remove ${names.length} volume(s)?`;
      msg += `\n\n‚ö†Ô∏è WARNING: This will permanently delete all data in these volumes.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Remove Docker Volumes',
            kind: 'warning',
            okLabel: 'Yes, Remove',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(50, 'Removing volumes...');
        const result = await invoke('clean_docker_volumes', { names });
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        if (result.success) {
          showDockerStatus(`‚úÖ Removed ${result.volumes_removed} volume(s)`);
        } else {
          showDockerStatus(`‚ö†Ô∏è ${result.message}`);
        }
        
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    async function cleanDockerNetworks() {
      const ids = getSelectedDockerNetworks();
      
      if (!ids.length) {
        showDockerStatus('Select at least one network');
        return;
      }

      let msg = `Are you sure you want to remove ${ids.length} network(s)?`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Remove Docker Networks',
            kind: 'warning',
            okLabel: 'Yes, Remove',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(50, 'Removing networks...');
        const result = await invoke('clean_docker_networks', { ids });
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        if (result.success) {
          showDockerStatus(`‚úÖ Removed ${result.networks_removed} network(s)`);
        } else {
          showDockerStatus(`‚ö†Ô∏è ${result.message}`);
        }
        
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    async function cleanDockerBuildCache() {
      let msg = `Are you sure you want to clear the Docker build cache?`;
      msg += `\n\nThis will free approximately ${formatSize(dockerBuildCacheSize)}.`;
      msg += `\n\nNote: Future builds may take longer as layers need to be rebuilt.`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Clear Build Cache',
            kind: 'warning',
            okLabel: 'Yes, Clear',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(50, 'Clearing build cache...');
        const result = await invoke('docker_builder_prune');
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        if (result.success) {
          showDockerStatus(`‚úÖ Build cache cleared. Freed ${formatSize(result.freed_bytes)}`);
        } else {
          showDockerStatus(`‚ö†Ô∏è ${result.message}`);
        }
        
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    async function pruneDockerAll() {
      let msg = `Are you sure you want to prune ALL unused Docker resources?`;
      msg += `\n\nThis will remove:`;
      msg += `\n‚Ä¢ All stopped containers`;
      msg += `\n‚Ä¢ All unused images`;
      msg += `\n‚Ä¢ All unused volumes`;
      msg += `\n‚Ä¢ All unused networks`;
      msg += `\n‚Ä¢ All build cache`;
      msg += `\n\n‚ö†Ô∏è This action cannot be undone!`;
      msg += `\n\nEstimated space to be freed: ${formatSize(dockerScanResult?.total_reclaimable || 0)}`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Prune All Docker Resources',
            kind: 'warning',
            okLabel: 'Yes, Prune All',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }

      if (!confirmed) return;

      showDockerProgress();
      hideDockerStatus();

      try {
        updateDockerProgress(30, 'Pruning containers...');
        await invoke('docker_prune_containers');
        
        updateDockerProgress(50, 'Pruning images...');
        await invoke('docker_prune_images', { all: true });
        
        updateDockerProgress(70, 'Pruning volumes...');
        await invoke('docker_prune_volumes');
        
        updateDockerProgress(85, 'Pruning networks...');
        await invoke('docker_prune_networks');
        
        updateDockerProgress(95, 'Pruning build cache...');
        await invoke('docker_builder_prune');
        
        updateDockerProgress(100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideDockerProgress();
        
        showDockerStatus(`‚úÖ All unused Docker resources have been pruned!`);
        await scanDocker();
      } catch (e) {
        hideDockerProgress();
        showDockerStatus('Error: ' + e);
      }
    }

    function showSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'block';
        const progressBar = document.getElementById(sectionId + 'ProgressBar');
        const progressText = document.getElementById(sectionId + 'ProgressText');
        if (progressBar) {
          progressBar.style.width = '0%';
          progressBar.textContent = '0%';
        }
        if (progressText) {
          progressText.textContent = '';
        }
      }
    }

    function updateSectionProgress(sectionId, percentage, message) {
      const progressBar = document.getElementById(sectionId + 'ProgressBar');
      const progressText = document.getElementById(sectionId + 'ProgressText');
      if (progressBar) {
        const clampedPercentage = Math.min(100, Math.max(0, percentage));
        progressBar.style.width = clampedPercentage + '%';
        progressBar.textContent = Math.round(clampedPercentage) + '%';
      }
      if (progressText && message) {
        progressText.textContent = message;
      }
    }

    function hideSectionProgress(sectionId) {
      const progressContainer = document.getElementById(sectionId + 'Progress');
      if (progressContainer) {
        progressContainer.style.display = 'none';
      }
    }

    function renderBasicCaches() {
      const section = document.getElementById('basicCachesSection');
      const list = document.getElementById('basicCachesList');

      // Filter to only show editor caches (VSCode and Cursor)
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });

      section.style.display = 'block';

      if (!editorCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No editor caches found</div></div></div>';
        document.getElementById('btnCleanBasic').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBasic').style.display = 'block';

      // Map with original indices for checkbox selection
      let editorIndex = 0;
      list.innerHTML = editorCaches.map((cache) => {
        const originalIndex = basicCaches.findIndex(c => c.cache_type === cache.cache_type && c.path === cache.path);
        const i = editorIndex++;
        return `
        <div class="cache-item">
          <input type="checkbox" id="bc${i}" data-index="${originalIndex}" class="bc-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            ${renderPaths(cache.path)}
          </div>
          <div class="cache-size ${cache.size > 0 ? '' : ''}">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `;
      }).join('');
    }

    function renderBrowserCaches() {
      const section = document.getElementById('browserCachesSection');
      const list = document.getElementById('browserCachesList');

      section.style.display = 'block';

      if (!browserCaches.length && !indexedDbItems.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No browser caches found</div></div></div>';
        document.getElementById('btnCleanBrowserCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanBrowserCaches').style.display = 'block';

      // Separate Chrome from other browsers
      const chromeCache = browserCaches.find(c => getCacheTypeString(c.cache_type).toLowerCase() === 'chrome');
      const otherBrowsers = browserCaches.filter(c => getCacheTypeString(c.cache_type).toLowerCase() !== 'chrome');
      
      let html = '';
      
      // Render Chrome with nested IndexedDB
      if (chromeCache || indexedDbItems.length > 0) {
        const chromeIndex = browserCaches.findIndex(c => getCacheTypeString(c.cache_type).toLowerCase() === 'chrome');
        const chromeCacheSize = chromeCache && chromeCache.exists ? chromeCache.size : 0;
        const indexedDbTotalSize = indexedDbItems.reduce((sum, item) => sum + item.size, 0);
        const hasIndexedDb = indexedDbItems.length > 0;
        
        html += `
          <div class="browser-item-container">
            <div class="browser-main-item">
              <input type="checkbox" 
                id="browser-chrome" 
                data-index="${chromeIndex}" 
                class="browser-checkbox chrome-main-checkbox" 
                ${chromeCache && chromeCache.exists && chromeCache.size > 0 ? 'checked' : ''}>
              <div class="cache-info">
                <div class="cache-name">üåê Chrome</div>
                ${chromeCache ? renderPaths(chromeCache.path) : '<div class="cache-path">Cache folder not found</div>'}
              </div>
              <div class="chrome-total-size">
                <div class="chrome-cache-size">${chromeCache && chromeCache.exists ? formatSize(chromeCacheSize) : '0 bytes'}</div>
                ${hasIndexedDb ? `<div class="chrome-indexeddb-size">+ ${formatSize(indexedDbTotalSize)} IndexedDB</div>` : ''}
              </div>
            </div>
            ${hasIndexedDb ? `
              <div class="indexeddb-subsection">
                <div class="indexeddb-header" onclick="toggleIndexedDbSection()">
                  <div class="indexeddb-header-left">
                    <span class="indexeddb-toggle" id="indexedDbToggle">‚ñº</span>
                    <span class="indexeddb-title">üíæ IndexedDB (Website Data)</span>
                    <span class="indexeddb-badge">${indexedDbItems.length} ${indexedDbItems.length === 1 ? 'origin' : 'origins'}</span>
                  </div>
                  <span class="indexeddb-total">${formatSize(indexedDbTotalSize)}</span>
                </div>
                <div class="indexeddb-description">
                  Local database storage used by websites in Chrome. Includes offline data, cached content, and app data.
                </div>
                <div class="indexeddb-select-all">
                  <input type="checkbox" id="idb-select-all" onchange="toggleAllIndexedDb(this.checked)" checked>
                  <label for="idb-select-all">Select all IndexedDB items</label>
                </div>
                <div class="indexeddb-items" id="indexedDbItems">
                  ${indexedDbItems.map((item, i) => `
                    <div class="indexeddb-item ${item.size > 50 * 1024 * 1024 ? 'large-item' : ''}">
                      <input type="checkbox" 
                        id="idb${i}" 
                        data-index="${i}" 
                        class="idb-checkbox" 
                        ${item.over_threshold ? 'checked' : ''}>
                      <div class="cache-info">
                        <div class="cache-name">${item.origin}</div>
                        <div class="cache-path">${item.profile} ‚Üí ${item.path}</div>
                      </div>
                      <div class="cache-size ${item.size > 50 * 1024 * 1024 ? 'large' : ''}">${formatSize(item.size)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      }
      
      // Render other browsers (Safari, Firefox, Arc)
      otherBrowsers.forEach((cache, i) => {
        const originalIndex = browserCaches.findIndex(c => c.cache_type === cache.cache_type && c.path === cache.path);
        html += `
          <div class="cache-item">
            <input type="checkbox" id="browser${originalIndex}" data-index="${originalIndex}" class="browser-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
            <div class="cache-info">
              <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
              ${renderPaths(cache.path)}
            </div>
            <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
          </div>
        `;
      });
      
      list.innerHTML = html;
    }
    
    function toggleIndexedDbSection() {
      const toggle = document.getElementById('indexedDbToggle');
      const items = document.getElementById('indexedDbItems');
      if (toggle && items) {
        toggle.classList.toggle('collapsed');
        items.classList.toggle('collapsed');
      }
    }
    
    function toggleAllIndexedDb(checked) {
      document.querySelectorAll('.idb-checkbox').forEach(cb => {
        cb.checked = checked;
      });
    }

    function renderPackageManagers() {
      const section = document.getElementById('packageManagersSection');
      const list = document.getElementById('packageManagersList');

      section.style.display = 'block';

      if (!packageManagers.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No package manager caches found</div></div></div>';
        document.getElementById('btnCleanPackageManagers').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanPackageManagers').style.display = 'block';

      list.innerHTML = packageManagers.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="pkg${i}" data-index="${i}" class="pkg-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            ${renderPaths(cache.path)}
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderDevTools() {
      const section = document.getElementById('devToolsSection');
      const list = document.getElementById('devToolsList');

      section.style.display = 'block';

      if (!devTools.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No development tool caches found</div></div></div>';
        document.getElementById('btnCleanDevTools').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanDevTools').style.display = 'block';

      list.innerHTML = devTools.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="dev${i}" data-index="${i}" class="dev-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            ${renderPaths(cache.path)}
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function renderSystemCaches() {
      const section = document.getElementById('systemCachesSection');
      const list = document.getElementById('systemCachesList');

      section.style.display = 'block';

      if (!systemCaches.length) {
        list.innerHTML = '<div class="cache-item"><div class="cache-info"><div class="cache-name">No system caches found</div></div></div>';
        document.getElementById('btnCleanSystemCaches').style.display = 'none';
        return;
      }

      document.getElementById('btnCleanSystemCaches').style.display = 'block';

      list.innerHTML = systemCaches.map((cache, i) => `
        <div class="cache-item">
          <input type="checkbox" id="sys${i}" data-index="${i}" class="sys-checkbox" ${cache.exists && cache.size > 0 ? 'checked' : ''}>
          <div class="cache-info">
            <div class="cache-name">${getCacheTypeName(cache.cache_type)}</div>
            ${renderPaths(cache.path)}
          </div>
          <div class="cache-size">${cache.exists ? formatSize(cache.size) : 'Not found'}</div>
        </div>
      `).join('');
    }

    function updateTotal() {
      // Only count editor caches (VSCode and Cursor) in basicCaches
      const editorCaches = basicCaches.filter(cache => {
        const type = cache.cache_type.toLowerCase();
        return ['vscode', 'code', 'cursor'].includes(type);
      });
      const bcTotal = editorCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const browserTotal = browserCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const pkgTotal = packageManagers.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const devTotal = devTools.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const sysTotal = systemCaches.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const idbTotal = indexedDbItems.reduce((sum, i) => sum + i.size, 0);
      document.getElementById('totalSize').textContent = formatSize(bcTotal + browserTotal + pkgTotal + devTotal + sysTotal + idbTotal);
    }

    function getSelectedIndexedDbItems() {
      return [...document.querySelectorAll('.idb-checkbox:checked')]
        .map(cb => indexedDbItems[parseInt(cb.dataset.index)]);
    }

    function getSelectedBasicCaches() {
      return [...document.querySelectorAll('.bc-checkbox:checked')]
        .map(cb => basicCaches[parseInt(cb.dataset.index)]);
    }

    async function scanData() {
      showStatus('Scanning...');
      try {
        const allCaches = await invoke('scan_caches');
        
        // Separate caches by category
        basicCaches = allCaches.filter(c => ['vscode', 'code', 'cursor'].includes(c.cache_type.toLowerCase()));
        browserCaches = allCaches.filter(c => ['chrome', 'safari', 'firefox', 'arc'].includes(c.cache_type.toLowerCase()));
        packageManagers = allCaches.filter(c => ['npm', 'yarn', 'pnpm', 'pip', 'cocoapods', 'gradle', 'cargo'].includes(c.cache_type.toLowerCase()));
        devTools = allCaches.filter(c => ['xcodederiveddata', 'xcodearchives', 'xcodesimulators'].includes(c.cache_type.toLowerCase()));
        systemCaches = allCaches.filter(c => ['cachedir', 'systemcaches', 'userlogs', 'tempfiles', 'iosbackups'].includes(c.cache_type.toLowerCase()));
        
        indexedDbItems = await invoke('scan_indexed_db_items', { thresholdMb: INDEXED_DB_THRESHOLD_MB });
        
        // Chrome warning removed - cleaning doesn't affect Chrome
        
        renderBasicCaches();
        renderBrowserCaches();  // This now includes IndexedDB under Chrome
        renderPackageManagers();
        renderDevTools();
        renderSystemCaches();
        updateTotal();
        hideStatus();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanBasicCaches() {
      const selectedBc = getSelectedBasicCaches();
      
      if (!selectedBc.length) {
        showStatus('Select at least one editor cache');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected editor caches?';
      const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('basicCaches');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedBc.length;

        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateSectionProgress('basicCaches', percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${totalItems}...`);
          
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          totalFreed += result.freed_bytes || 0;
        }
        
        updateSectionProgress('basicCaches', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('basicCaches');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('basicCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanIndexedDbItems() {
      const selectedIdb = getSelectedIndexedDbItems();
      
      if (!selectedIdb.length) {
        showStatus('Select at least one IndexedDB item');
        return;
      }
      
      let msg = 'Are you sure you want to clean the selected IndexedDB items?';
      msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: No dialog available.');
          return;
        }
      } catch (err) {
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      if (!confirmed) {
        return;
      }

      showSectionProgress('indexedDb');
      hideStatus();

      try {
        let totalFreed = 0;
        const totalItems = selectedIdb.length;

        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          const percentage = Math.min(99, ((i + 1) / totalItems) * 100);
          updateSectionProgress('indexedDb', percentage, `Cleaning IndexedDB ${i + 1}/${totalItems} (${idbItem.origin})...`);
          
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          totalFreed += idbResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('indexedDb', 100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('indexedDb');
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        await scanData();
      } catch(e) {
        hideSectionProgress('indexedDb');
        showStatus('Error: ' + e);
      }
    }

    async function cleanBrowserCaches() {
      const selectedBrowsers = [...document.querySelectorAll('.browser-checkbox:checked')]
        .map(cb => {
          const index = parseInt(cb.dataset.index);
          return index >= 0 ? browserCaches[index] : null;
        })
        .filter(c => c !== null);
      
      const selectedIdb = getSelectedIndexedDbItems();
      
      if (!selectedBrowsers.length && !selectedIdb.length) {
        showStatus('Select at least one browser cache or IndexedDB item');
        return;
      }
      
      // Calculate totals for confirmation message
      const browserTotal = selectedBrowsers.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
      const idbTotal = selectedIdb.reduce((sum, i) => sum + i.size, 0);
      
      let msg = 'Are you sure you want to clean the selected browser data?';
      if (selectedBrowsers.length) {
        msg += `\n\nüåê Browser caches: ${selectedBrowsers.length} item(s) (${formatSize(browserTotal)})`;
      }
      if (selectedIdb.length) {
        msg += `\n\nüíæ Chrome IndexedDB: ${selectedIdb.length} origin(s) (${formatSize(idbTotal)})`;
        msg += '\n‚ö†Ô∏è This will remove website local storage data.';
      }
      
      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Browser Data Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else {
          confirmed = window.confirm(msg);
        }
      } catch (err) {
        confirmed = window.confirm(msg);
      }
      
      if (!confirmed) return;
      
      showSectionProgress('browserCaches');
      hideStatus();
      
      const totalItems = selectedBrowsers.length + selectedIdb.length;
      let currentItem = 0;
      let totalFreed = 0;
      
      try {
        // Clean browser caches
        for (let i = 0; i < selectedBrowsers.length; i++) {
          const cache = selectedBrowsers[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateSectionProgress('browserCaches', percentage, `Cleaning ${getCacheTypeName(cache.cache_type)} cache...`);
          
          const result = await invoke('clean_cache', { 
            cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), 
            dryRun: false 
          });
          totalFreed += result.freed_bytes || 0;
        }
        
        // Clean IndexedDB items
        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateSectionProgress('browserCaches', percentage, `Cleaning IndexedDB: ${idbItem.origin}...`);
          
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          totalFreed += idbResult.total_freed_bytes || 0;
        }
        
        updateSectionProgress('browserCaches', 100, 'Completed!');
        await new Promise(resolve => setTimeout(resolve, 500));
        hideSectionProgress('browserCaches');
        showStatus('‚úÖ Browser data cleaned! Freed ' + formatSize(totalFreed));
        await scanData();
      } catch (e) {
        hideSectionProgress('browserCaches');
        showStatus('Error: ' + e);
      }
    }

    async function cleanPackageManagers() {
      const selected = [...document.querySelectorAll('.pkg-checkbox:checked')]
        .map(cb => packageManagers[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one package manager cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Package manager caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanDevTools() {
      const selected = [...document.querySelectorAll('.dev-checkbox:checked')]
        .map(cb => devTools[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one dev tool cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          await invoke('clean_cache', { cacheType: getCacheTypeString(cache.cache_type).toLowerCase(), dryRun: false });
        }
        showStatus('‚úÖ Dev tool caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSystemCaches() {
      const selected = [...document.querySelectorAll('.sys-checkbox:checked')]
        .map(cb => systemCaches[parseInt(cb.dataset.index)]);
      
      if (!selected.length) {
        showStatus('Select at least one system cache');
        return;
      }
      
      try {
        for (const cache of selected) {
          const cacheType = getCacheTypeString(cache.cache_type).toLowerCase();
          console.log('[UI] Cleaning system cache:', cacheType);
          await invoke('clean_cache', { cacheType: cacheType, dryRun: false });
        }
        showStatus('‚úÖ System caches cleaned');
        await scanData();
      } catch (e) {
        showStatus('Error: ' + e);
      }
    }

    async function previewClean() {
      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();
      
      if (!selectedBc.length && !selectedIdb.length) { 
        showStatus('Select at least one item'); 
        return; 
      }
      
      showStatus('Previewing...');
      try {
        let results = [];
        
        for (const cache of selectedBc) {
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: true 
          });
          if (result.freed_bytes > 0) {
            const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
            results.push(`${cacheTypeName}: ${formatSize(result.freed_bytes)}`);
          }
        }
        
        if (selectedIdb.length) {
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: selectedIdb.map(i => i.path),
            dryRun: true
          });
          if (idbResult.items_removed) {
            results.push(`IndexedDB (${idbResult.items_removed} origins): ${formatSize(idbResult.total_freed_bytes)}`);
          }
        }
        
        showStatus('Would free:\n' + results.join('\n'));
      } catch(e) {
        showStatus('Error: ' + e);
      }
    }

    async function cleanSelected() {
      console.log("[UI] Clean Selected clicked");

      const selectedBc = getSelectedBasicCaches();
      const selectedIdb = getSelectedIndexedDbItems();

      console.log("[UI] Selected basic caches:", selectedBc);
      
      if (!selectedBc.length && !selectedIdb.length) { 
        console.warn("[UI] No items selected");
        showStatus('Select at least one item'); 
        return; 
      }
      
      let msg = 'Are you sure you want to clean the selected items?';
      if (selectedBc.length) {
        const bcTotal = selectedBc.reduce((sum, c) => sum + (c.exists ? c.size : 0), 0);
        msg += `\n\n‚ö†Ô∏è WARNING: Will clean ${selectedBc.length} editor cache(s) (${formatSize(bcTotal)}).`;
      }
      if (selectedIdb.length) {
        msg += `\n\n‚ö†Ô∏è WARNING: Cleaning IndexedDB will remove site data for ${selectedIdb.length} origin(s).`;
      }

      let confirmed = false;
      try {
        const tauri = window.__TAURI__;
        if (tauri && tauri.dialog) {
          console.log("[UI] Using Tauri dialog.ask");
          confirmed = await tauri.dialog.ask(msg, {
            title: 'Confirm Cleanup',
            kind: 'warning',
            okLabel: 'Yes, Clean',
            cancelLabel: 'Cancel'
          });
        } else if (typeof window.confirm === 'function') {
          console.log("[UI] Falling back to window.confirm");
          confirmed = window.confirm(msg);
        } else {
          console.warn("[UI] No confirm dialog available, requiring explicit confirmation");
          showStatus('Error: No dialog available. Please use a browser with confirm support.');
          return;
        }
      } catch (err) {
        console.error("[UI] Error while showing confirm dialog:", err);
        // Fallback to window.confirm if Tauri dialog fails
        if (typeof window.confirm === 'function') {
          confirmed = window.confirm(msg);
        } else {
          showStatus('Error: Could not show confirmation dialog. ' + err);
          return;
        }
      }

      console.log("[UI] Confirm result:", confirmed);
      if (!confirmed) {
        console.log("[UI] User cancelled clean confirmation dialog");
        return;
      }

      // Calculate total items to clean (each item individually)
      const totalItems = selectedBc.length + selectedIdb.length;
      let currentItem = 0;

      // Show progress bar
      showProgress();
      hideStatus();
      console.log("[UI] Starting clean operation... Total items:", totalItems);
      
      try {
        let totalFreed = 0;
        
        // Clean basic caches - one by one
        for (let i = 0; i < selectedBc.length; i++) {
          const cache = selectedBc[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          const cacheTypeName = cache.cache_type.charAt(0).toUpperCase() + cache.cache_type.slice(1).toLowerCase();
          updateProgress(percentage, `Cleaning ${cacheTypeName} cache ${i + 1}/${selectedBc.length}...`);
          
          console.log("[UI] Invoking clean_cache for:", cache.cache_type);
          const result = await invoke('clean_cache', { 
            cacheType: cache.cache_type.toLowerCase(), 
            dryRun: false 
          });
          console.log("[UI] clean_cache result:", result);
          totalFreed += result.freed_bytes || 0;
        }
        
        // Clean IndexedDB - one by one
        for (let i = 0; i < selectedIdb.length; i++) {
          const idbItem = selectedIdb[i];
          currentItem++;
          const percentage = Math.min(99, (currentItem / totalItems) * 100);
          updateProgress(percentage, `Cleaning IndexedDB ${i + 1}/${selectedIdb.length} (${idbItem.origin})...`);
          
          console.log("[UI] Invoking clean_indexed_db_items for origin:", idbItem.origin);
          const idbResult = await invoke('clean_indexed_db_items', {
            paths: [idbItem.path],
            dryRun: false
          });
          console.log("[UI] clean_indexed_db_items result:", idbResult);
          totalFreed += idbResult.total_freed_bytes || 0;
        }
        
        // Only set 100% after ALL items are actually deleted
        updateProgress(100, 'Cleaning completed!');
        await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay to show 100%
        hideProgress();
        showStatus('‚úÖ Freed ' + formatSize(totalFreed));
        console.log("[UI] Clean operation finished. Total freed bytes:", totalFreed);
        await scanData();
      } catch(e) {
        console.error("[UI] Error during cleanSelected:", e);
        hideProgress();
        showStatus('Error: ' + e);
      }
    }

    // Initialize
    function initializeEventHandlers() {
      // Cache Cleaner
      document.getElementById('btnScan').addEventListener('click', scanData);
      document.getElementById('btnPreview').addEventListener('click', previewClean);
      document.getElementById('btnClean').addEventListener('click', cleanSelected);
      document.getElementById('btnCleanBasic').addEventListener('click', cleanBasicCaches);
      document.getElementById('btnCleanBrowserCaches').addEventListener('click', cleanBrowserCaches);
      document.getElementById('btnCleanPackageManagers').addEventListener('click', cleanPackageManagers);
      document.getElementById('btnCleanDevTools').addEventListener('click', cleanDevTools);
      document.getElementById('btnCleanSystemCaches').addEventListener('click', cleanSystemCaches);
      
      // Tab navigation
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
      });
      
      // Smart Scanner
      document.getElementById('btnSmartScan').addEventListener('click', scanSmartSuggestions);
      document.getElementById('btnCleanSmartScanner').addEventListener('click', deleteSmartScannerFolders);
      
      // Docker Cleanup
      document.getElementById('btnDockerScan').addEventListener('click', scanDocker);
      document.getElementById('btnDockerPruneAll').addEventListener('click', pruneDockerAll);
      document.getElementById('btnCleanDockerContainers').addEventListener('click', cleanDockerContainers);
      document.getElementById('btnCleanDockerImages').addEventListener('click', cleanDockerImages);
      document.getElementById('btnCleanDockerVolumes').addEventListener('click', cleanDockerVolumes);
      document.getElementById('btnCleanDockerNetworks').addEventListener('click', cleanDockerNetworks);
      document.getElementById('btnCleanDockerBuildCache').addEventListener('click', cleanDockerBuildCache);
    }

    if (window.__TAURI__) {
      console.log("[UI] Tauri detected, initializing immediately");
      invoke = window.__TAURI__.core.invoke;
      initializeEventHandlers();
      scanData();
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (window.__TAURI__) {
            console.log("[UI] Tauri became available after DOMContentLoaded");
            invoke = window.__TAURI__.core.invoke;
            initializeEventHandlers();
            scanData();
          } else {
            showStatus('Tauri API not available');
          }
        }, 100);
      });
    }
  </script>
</body>
</html>
